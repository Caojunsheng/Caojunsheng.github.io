<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Chenruohan个人博客 | First Post</title>
    <meta name="description" content="第一个博客，测试博客 ">
    <link rel="canonical" href="https://caojunsheng.github.io/posts/first-post/" />
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <meta property="og:title" content="First Post" />
<meta property="og:description" content="第一个博客，测试博客" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://caojunsheng.github.io/posts/first-post/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-17T17:11:28+08:00" />
<meta property="article:modified_time" content="2022-09-18T18:09:34+08:00" />



    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="First Post"/>
<meta name="twitter:description" content="第一个博客，测试博客"/>

    
        
    

    
    <link rel="stylesheet" href='/css/style.css' />
    <link rel="stylesheet" href='/css/search.css' />
    <link rel="stylesheet" href='/css/list.css' />
    <link rel="stylesheet" href='/css/terms.css' />
    <link rel="stylesheet" href='/css/taxonomy.css' />
    <link rel="stylesheet" href='/css/home.css' />
    <link rel="stylesheet" href='/css/syntax.css' />
    
    <link rel="stylesheet" href='/css/shortcode.css' />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href='/css/_custom.css' />
    <style>

         
    </style>

    

    

    <script>
    MathJax = {
      tex: {
        inlineMath: [["$", "$"]],
      },
      displayMath: [
        ["$$", "$$"],
        ["\[\[", "\]\]"],
      ],
      svg: {
        fontCache: "global",
      },
    };
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script
    id="MathJax-script"
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
  ></script>



    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    
    <script src="/js/lazysizes.min.js" async=""></script>
    
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    
    <script src="/js/search.js"></script>

    <script src="/js/yes.js"></script>
    
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
</head><body style="font-family: ,'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'Heiti SC', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;">
        <div class="loading">
            <div class="loading-bg"></div>
            <div class="loading-long">
                <div class="loading-short"></div>
            </div>
        </div>
        
        <header>
    <nav class="navbar">
        
        <div class="navbar-brand">
            
            <a href="/">
                <span class="logo">Chenruohan个人博客</span>
            </a>
        </div>
        
        <div class="navbar-menu">
            
            
            <a href="/">
                <div class="menu-item">
                    <div class="hengtiao-root">
                        
                        <div class="hengtiao"></div>
                        <div class="name text-wbd-reverse"><i class='fa fa-home'></i> 首页</div>
                    </div>
                </div>
            </a>
            
            <a href="/posts">
                <div class="menu-item">
                    <div class="hengtiao-root">
                        
                        <div class="hengtiao"></div>
                        <div class="name text-wbd-reverse"><i class='fa fa-book'></i> 文章</div>
                    </div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="menu-item">
                    <div class="hengtiao-root">
                        
                        <div class="hengtiao"></div>
                        <div class="name text-wbd-reverse"><i class='fa fa-folder-open'></i> 分类</div>
                    </div>
                </div>
            </a>
            
            <a href="/series">
                <div class="menu-item">
                    <div class="hengtiao-root">
                        
                        <div class="hengtiao"></div>
                        <div class="name text-wbd-reverse"><i class='fa fa-gears'></i> 系列</div>
                    </div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="menu-item">
                    <div class="hengtiao-root">
                        
                        <div class="hengtiao"></div>
                        <div class="name text-wbd-reverse"><i class='fa fa-tags'></i> 标签</div>
                    </div>
                </div>
            </a>
            
            <a href="/about">
                <div class="menu-item">
                    <div class="hengtiao-root">
                        
                        <div class="hengtiao"></div>
                        <div class="name text-wbd-reverse"><i class='fa fa-info-circle'></i> 关于</div>
                    </div>
                </div>
            </a>
            
            
            
            <div class="navbar-burger">
                <div class="burger-btn"><span><i class="fa fa-navicon"></i></span></div>
            </div>
            <div class="search-in"><span><i class="fa fa-search"></i></span></div>
            <div class="mode">
                <span class="sun"><i class="fa fa-sun-o"></i></span>
                <span class="moon"><i class="fa fa-moon-o"></i></span>
            </div>
        </div>

    </nav>
    
    <div class="burger-items">
        
        <a href="/">
            <div class="burger-item">
                <i class='fa fa-home'></i> 首页
            </div>
        </a>
        
        <a href="/posts">
            <div class="burger-item">
                <i class='fa fa-book'></i> 文章
            </div>
        </a>
        
        <a href="/categories">
            <div class="burger-item">
                <i class='fa fa-folder-open'></i> 分类
            </div>
        </a>
        
        <a href="/series">
            <div class="burger-item">
                <i class='fa fa-gears'></i> 系列
            </div>
        </a>
        
        <a href="/tags">
            <div class="burger-item">
                <i class='fa fa-tags'></i> 标签
            </div>
        </a>
        
        <a href="/about">
            <div class="burger-item">
                <i class='fa fa-info-circle'></i> 关于
            </div>
        </a>
        
    </div>
    <div class="header-rest"></div>
      
</header>

        <div id="content">









    <div class="hero">
        
        
            <div class="hero-img">
                <img src="/images/default.jpeg" alt="">
            </div>
        
        <div class="hero-content">
            
            <div class="hero-title">First Post</div>
            <div class="hero-subtitle"></div>
            
            <div class="hero-date">
                
                
                    <span class="no-wrap"><i class="fa fa-calendar"></i> 发布于: 2022-9-17 &nbsp;</span>
                    <span class="no-wrap"><i class="fa fa-calendar-check-o"></i> 更新于: 2022-9-18 &nbsp;</span>
                    <span class="no-wrap"><i class="fa fa-folder"></i>
                        收录于:
                        
                            <a href='/categories/build-site-guide'>
                                Build Site Guide
                            </a>
                    </span>    
                
            </div>
            <div class="timelong">
                
                <span class="no-wrap"><i class="fa fa-pencil"></i> 本文字数: 26 &nbsp;</span>
                <span class="no-wrap"><i class="fa fa-clock-o"></i> 阅读时长: 1 分钟 &nbsp;</span>
                <span class="no-wrap"><i class="fa fa-eye"></i> 阅读量: <span id="busuanzi_value_page_pv"></span></span>
            </div>
        </div>
    </div>




<div class="zhuti-0">
    <div class="container">
        <div class="zhuti">
            
            <div class="zhuti-l">
                
                



    


<div class="content-root">
    <div class="long">
        
        <button class="tosides-1 text-wbd">
            <i class="fa fa-arrow-right"></i>
        </button>
        <button class="tosides-2 text-wbd">
            <i class="fa fa-arrow-left"></i>
        </button>
        <button class="toup text-wbd">
            <i class="fa fa-arrow-up"></i>
        </button>
    </div>
    
        
        <div class="content">
            <div class="content-self">
                <blockquote>
<p>This is My First Blog</p>
</blockquote>
<h2 id="我告诉你出来混有错就要认挨打要立正">我告诉你，出来混，有错就要认，挨打要立正。</h2>
<p><img src="/images/tmp2.jpg" alt=""></p>

            </div>
            
                <div class="tags">
                    
                    <span class="down-type-item">
                        <div class="type-text">
                            <a href='/tags/hugo'>
                            <i class="fa fa-tag"></i> hugo
                        </a>
                        </div>
                    </span>
                    
                </div>
            
        </div>
        
            
            
                <div class="pre-next">
                    
    
        
        <a href="https://caojunsheng.github.io/posts/golang/05_chan_close/" class="pre pre-last" style="text-align: center;">
            <span class="pre-icon"><i class="fa fa-hand-o-left"></i></span>
            <div class="pre-title-root">
                <span>golang chan close源码分析</span>
            </div>
        </a>
        
    


                </div>
            
        

    
    
</div>


    <div class="content-last">
        <button class="aixin content-last-item efct-button">
            <i class="fa fa-heart"></i>
        </button>
        
    </div>


            </div>
            
            <div class="zhuti-r">
                
<div class="zhuti-r-0">
    
    <div class="zhuti-r-1">
        
        
        <div id="r1">
            
            <div class="about-zuozhe">
    <div class="zuozhe">
        
            <div class="datou">
                <img src="/images/author.jpeg" alt="">
            </div>
        
        <div class="name-jianjie">
            <div class="name">chenruohan</div>
            <div class="jianjie">
                人生如戏，戏如人生
            </div>
        </div>
    </div>
    <div class="type">
        <a href="/posts" class="wenzhang">
            <p>文章</p>
            <p>7</p>
        </a>
        <a href="/categories" class="fenlei">
            <p>分类</p>
            <p>2</p>
        </a>
        <a href="/tags" class="biaoqian">
            <p>标签</p>
            <p>4</p>
        </a>
    </div>
    <a href="https://github.com/caojunsheng">
        <div class="follow">Follow Me</div>
    </a>
    <div class="link">
        
        <a href="https://github.com/caojunsheng" class="link-item is-hidden-desktop" title="GitHub">
            <span class="icon"><i class='fa fa-github'></i></span>
        </a>
        
        <a href="https://www.youtube.com" class="link-item is-hidden-desktop" title="YouTube">
            <span class="icon"><i class='fa fa-youtube'></i></span>
        </a>
        
    </div>
</div>
            
            <div class="mulu">
    <div class="dong"></div>
    <div class="zhi">
        <div class="wenzi">
            <div class="zhi-mulu text-wbd">目录</div>
            <div class="mulu-items">
            </div>
        </div>
    </div>
</div>
            
            



    
    



<div class="other">
    <div class="other-up">
        <div class="other-qita text-wbd">相关文章</div>
        <div class="xian"></div>
    </div>
    <div class="list">
        
    </div>
</div>
        </div>
        <div id="r2">
                
            
        </div> 
    </div>
</div>

            </div>
        </div>
    </div>
</div>


<div class="appreciate">
    <div class="appreciate-self">
        <div class="appreciate-title">赞赏</div>
        <div class="appreciate-btn">
            
                
                    <div class="appre-btn-1">微信</div>
                

                
            
        </div>
        
        <div class="appreciate-img">
            
                
                    <img class="appre-img-1" src="/images/appreciate/wechat.jpg" alt="">
                
                
            
        </div>
        <div class="cancel efct-button">取消</div>
    </div>
</div>




        </div>
        <footer class="footer">
    
        <div class="container">
            <div class="footer-items">
                
                    <div class="footer-item">
                        <i class="fa fa-user"></i> <span id="busuanzi_value_site_pv"></span> |
                        <i class="fa fa-eye"></i> <span id="busuanzi_value_site_uv"></span>
                    </div>
                
                
                    <div class="footer-item">
                        © 2022-2022 <a href="https://github.com/caojunsheng">chenruohan</a>
                    </div>
                
                
                    <div class="footer-item">
                        Theme by <a href="https://github.com/xioyito/NewBee">NewBee</a> | Powered by <a href="https://gohugo.io/">Hugo</a>
                    </div>
                
            </div>
        </div>
    
    
    
</footer>



        <div class="search-root">
    <div class="search-zz"></div>
    <div class="search">
        
        <div class="sheader anniu">
            <div class="sh-l">
                <input type="text" placeholder="输入关键字" id="search-key">
                <span class="sclear"><i class="fa fa-close"></i></span>
            </div>
            <div class="sh-r">
                <button>搜索</button>
            </div> 
        </div>

        <div class="sbody">
            <div class="sbody-1">
                <div class="stip"></div>
            </div>
            
        </div>
    </div>
</div>
        




    
    

    
    

    
    

    
    

    
    

    
    

    
    




<script type="text/javascript">
    var postsCount =  7 ;
    var arrPosts = [{"link":"https://caojunsheng.github.io/posts/first-post/","plain":" This is My First Blog\n我告诉你，出来混，有错就要认，挨打要立正。 ","pubDate":"2022-09-17","title":"First Post"},{"link":"https://caojunsheng.github.io/posts/golang/05_chan_close/","plain":"4、chan关闭流程 参考https://www.bookstack.cn/read/qcrao-Go-Questions/channel.md\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 func closechan(c *hchan) { if c == nil { // 关闭nil的chan直接panic panic(plainError(\u0026#34;close of nil channel\u0026#34;)) } lock(\u0026amp;c.lock) if c.closed != 0 { unlock(\u0026amp;c.lock) // 关闭已关闭的chan直接panic panic(plainError(\u0026#34;close of closed channel\u0026#34;)) } if raceenabled { callerpc := getcallerpc() racewritepc(c.raceaddr(), callerpc, funcPC(closechan)) racerelease(c.raceaddr()) } // 标志位打上 c.closed = 1 var glist gList // release all readers for { sg := c.recvq.dequeue() if sg == nil { break } // 赋值零值 if sg.elem != nil { typedmemclr(c.elemtype, sg.elem) sg.elem = nil } if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } // release all writers (they will panic) for { sg := c.sendq.dequeue() if sg == nil { break } // 发送者会panic sg.elem = nil if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } unlock(\u0026amp;c.lock) // Ready all Gs now that we\u0026#39;ve dropped the channel lock. for !glist.empty() { gp := glist.pop() gp.schedlink = 0 goready(gp, 3) } } ","pubDate":"2021-09-17","title":"golang chan close源码分析"},{"link":"https://caojunsheng.github.io/posts/golang/03_chan_recv/","plain":"2、chan读取源码分析 chan的读取源码入口是如下两个函数：\n1 2 3 4 5 6 7 8 9 // 读取的数据放在elem里面，两种读取的方式，第一种直接返回值，第二种返回一个bool值，判断chan是否关闭 func chanrecv1(c *hchan, elem unsafe.Pointer) { chanrecv(c, elem, true) } func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) { _, received = chanrecv(c, elem, true) return } chanrecv1不返回ok，chanrecv2返回ok，两个最终都是调用chanrecv函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 // src/runtime/chan.go:454 // chanrecv 函数接收 channel c 的元素并将其写入 ep 所指向的内存地址。 // 如果 ep 是 nil，说明忽略了接收值。 // 如果 block == false，即非阻塞型接收，在没有数据可接收的情况下，返回 (false, false) // 否则，如果 c 处于关闭状态，将 ep 指向的地址清零，返回 (true, false) // 否则，用返回值填充 ep 指向的内存地址。返回 (true, true) // 如果 ep 非空，则应该指向堆或者函数调用者的栈 func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { ... // 如果chan是nil的话 if c == nil { // 非阻塞调用，则直接返回false, false if !block { return } // 阻塞调用，一直等待接收nil的chan，goroutine挂起 gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2) throw(\u0026#34;unreachable\u0026#34;) } // 如果是非阻塞且chan是空的 if !block \u0026amp;\u0026amp; empty(c) { // 如果chan是未关闭的，直接返回false,false if atomic.Load(\u0026amp;c.closed) == 0 { return } // chan已经关闭，并且为空，老实说。这段代码感觉有点多余，下面也处理了这种情况 if empty(c) { // The channel is irreversibly closed and empty. if raceenabled { raceacquire(c.raceaddr()) } if ep != nil { // 对于已关闭的chan执行接收，不忽略返回值的情况下，会受到该类型的零值，清理ep的内存 typedmemclr(c.elemtype, ep) } // 返回selected为true return true, false } } var t0 int64 if blockprofilerate \u0026gt; 0 { t0 = cputicks() } lock(\u0026amp;c.lock) // chan已经关闭，且缓存中无数据，直接返回该类型的零值 if c.closed != 0 \u0026amp;\u0026amp; c.qcount == 0 { if raceenabled { raceacquire(c.raceaddr()) } unlock(\u0026amp;c.lock) if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } if sg := c.sendq.dequeue(); sg != nil { // 如果sender中有等待发送，那么可以分为两种情况 // 1、非缓冲队列，即同步chan，则直接从sender中接收值。 // 2、缓冲队列，即异步chan，从缓冲队列的头部拷贝到接收者，拷贝发送队列的值到缓冲队列末尾 recv(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true, true } // 缓冲型chan，buf里面有元素，直接从buf里面拿 if c.qcount \u0026gt; 0 { // Receive directly from queue qp := chanbuf(c, c.recvx) if raceenabled { racenotify(c, c.recvx, nil) } // 代码里面需要接收值，则需要拷贝值，比如接收是`val\u0026lt;-ch`，而不是`\u0026lt;-ch`，需要把chan的值拷贝到val if ep != nil { typedmemmove(c.elemtype, ep, qp) } // 清空掉原来buf中对应位置的值 typedmemclr(c.elemtype, qp) // 接收index+1 c.recvx++ // 如果接收索引已经到末尾，重新移到队首 if c.recvx == c.dataqsiz { c.recvx = 0 } // 缓冲区大小减一 c.qcount-- // 解锁 unlock(\u0026amp;c.lock) return true, true } if !block { // 非阻塞接收，解锁，返回false,false unlock(\u0026amp;c.lock) return false, false } // 无发送者，这个接收值需要被阻塞. gp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // 构造一个接收数据的sudog. mysg.elem = ep mysg.waitlink = nil gp.waiting = mysg mysg.g = gp mysg.isSelect = false mysg.c = c gp.param = nil // 放入接受者队列中 c.recvq.enqueue(mysg) // 将goroutine挂起 atomic.Store8(\u0026amp;gp.parkingOnChan, 1) gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, 2) // someone woke us up if mysg != gp.waiting { throw(\u0026#34;G waiting list is corrupted\u0026#34;) } gp.waiting = nil gp.activeStackChans = false if mysg.releasetime \u0026gt; 0 { blockevent(mysg.releasetime-t0, 2) } success := mysg.success gp.param = nil mysg.c = nil releaseSudog(mysg) return true, success } empty源码分析\n如果是非缓冲型，且sendq中无goroutine\n缓冲型，但是buf里面没有元素\n1 2 3 4 5 6 7 func empty(c *hchan) bool { // c.dataqsiz is immutable. if c.dataqsiz == 0 { return atomic.Loadp(unsafe.Pointer(\u0026amp;c.sendq.first)) == nil } return atomic.Loaduint(\u0026amp;c.qcount) == 0 } ","pubDate":"2021-09-17","title":"golang chan recv源码分析"},{"link":"https://caojunsheng.github.io/posts/golang/04_chan_send/","plain":"3、chan写入源码分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { // 如果chan是空 if c == nil { // 非阻塞，直接返回false，表示未发送成功 if !block { return false } // 阻塞的，挂起goroutine gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2) throw(\u0026#34;unreachable\u0026#34;) } ... // 如果是非阻塞的，chan未关闭，且chan的buffer已经满了，则返回发送失败 if !block \u0026amp;\u0026amp; c.closed == 0 \u0026amp;\u0026amp; full(c) { return false } var t0 int64 if blockprofilerate \u0026gt; 0 { t0 = cputicks() } lock(\u0026amp;c.lock) if c.closed != 0 { unlock(\u0026amp;c.lock) // 如果chan已经关闭了，再向chan发送数据，直接报panic panic(plainError(\u0026#34;send on closed channel\u0026#34;)) } if sg := c.recvq.dequeue(); sg != nil { // 如果有接受者在等待，直接将发送的数据拷贝到 send(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true } // 如果缓冲的chan，还有空间，将发送的数据拷贝到buffer中 if c.qcount \u0026lt; c.dataqsiz { qp := chanbuf(c, c.sendx) if raceenabled { racenotify(c, c.sendx, nil) } typedmemmove(c.elemtype, qp, ep) // 发送游标+1 c.sendx++ // 发送游标已经到末尾了，重新移到队头 if c.sendx == c.dataqsiz { c.sendx = 0 } // 缓冲区数量+1 c.qcount++ unlock(\u0026amp;c.lock) return true } // 非阻塞的chan，直接返回写入失败 if !block { unlock(\u0026amp;c.lock) return false } // chan满了，发送者会被阻塞，构造一个sudog挂起 gp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } mysg.elem = ep mysg.waitlink = nil mysg.g = gp mysg.isSelect = false mysg.c = c gp.waiting = mysg gp.param = nil // 构造sudog放入发送者队列 c.sendq.enqueue(mysg) atomic.Store8(\u0026amp;gp.parkingOnChan, 1) gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, 2) KeepAlive(ep) // someone woke us up. if mysg != gp.waiting { throw(\u0026#34;G waiting list is corrupted\u0026#34;) } gp.waiting = nil gp.activeStackChans = false closed := !mysg.success gp.param = nil if mysg.releasetime \u0026gt; 0 { blockevent(mysg.releasetime-t0, 2) } mysg.c = nil releaseSudog(mysg) if closed { if c.closed == 0 { throw(\u0026#34;chansend: spurious wakeup\u0026#34;) } panic(plainError(\u0026#34;send on closed channel\u0026#34;)) } return true } send源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // send 函数处理向一个空的 channel 发送操作 // ep 指向被发送的元素，会被直接拷贝到接收的 goroutine // 之后，接收的 goroutine 会被唤醒 // c 必须是空的（因为等待队列里有 goroutine，肯定是空的） // c 必须被上锁，发送操作执行完后，会使用 unlockf 函数解锁 // sg 必须已经从等待队列里取出来了 // ep 必须是非空，并且它指向堆或调用者的栈 func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { // 省略一些用不到的 // …… // sg.elem 指向接收到的值存放的位置，如 val \u0026lt;- ch，指的就是 \u0026amp;val if sg.elem != nil { // 直接拷贝内存（从发送者到接收者） sendDirect(c.elemtype, sg, ep) sg.elem = nil } // sudog 上绑定的 goroutine gp := sg.g // 解锁 unlockf() gp.param = unsafe.Pointer(sg) if sg.releasetime != 0 { sg.releasetime = cputicks() } // 唤醒接收的 goroutine. skip 和打印栈相关，暂时不理会 goready(gp, skip+1) } full源码\n1 2 3 4 5 6 7 8 func full(c *hchan) bool { // 非缓冲chan，判断recvq为空，则认为满 if c.dataqsiz == 0 { return c.recvq.first == nil } // 缓冲chan，缓冲区数量等于chan大小 return c.qcount == c.dataqsiz } ","pubDate":"2021-09-17","title":"golang chan send源码分析"},{"link":"https://caojunsheng.github.io/posts/golang/02_chan_data_structure/","plain":"二、chan源码解读 1、chan数据结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 type hchan struct { // chan 里元素数量 qcount uint // chan 底层循环数组的长度 dataqsiz uint // 指向底层循环数组的指针 // 只针对有缓冲的 channel buf unsafe.Pointer // chan 中元素大小 elemsize uint16 // chan 是否被关闭的标志 closed uint32 // chan 中元素类型 elemtype *_type // element type // 已发送元素在循环数组中的索引 sendx uint // send index // 已接收元素在循环数组中的索引 recvx uint // receive index // 等待接收的 goroutine 队列 recvq waitq // list of recv waiters // 等待发送的 goroutine 队列 sendq waitq // list of send waiters // 保护 hchan 中所有字段 lock mutex } type waitq struct { first *sudog last *sudog } buf 指向底层循环数组，只有缓冲型的 channel 才有。\nsendx，recvx 均指向底层循环数组，表示当前可以发送和接收的元素位置索引值（相对于底层数组）。\nsendq，recvq 分别表示被阻塞的 goroutine，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据而被阻塞。\nwaitq 是 sudog 的一个双向链表，而 sudog 实际上是对 goroutine 的一个封装。\n例如，创建一个容量为 6 的，元素为 int 型的 channel 数据结构如下 ： ","pubDate":"2021-09-17","title":"golang chan数据结构"},{"link":"https://caojunsheng.github.io/posts/golang/01_chan/","plain":"一、golang里面几个chan常见的坑 1、向chan发送数据 向已关闭的chan发送数据会panic\n1 2 3 4 5 // src/runtime/chan.go:202 if c.closed != 0 { unlock(\u0026amp;c.lock) panic(plainError(\u0026#34;send on closed channel\u0026#34;)) } 2、关闭chan 关闭nil的chan，会panic 对已关闭的chan，再次关闭chan，会panic 1 2 3 4 5 6 7 8 9 10 11 12 13 // src/runtime/chan.go:355 func closechan(c *hchan) { if c == nil { panic(plainError(\u0026#34;close of nil channel\u0026#34;)) } lock(\u0026amp;c.lock) if c.closed != 0 { unlock(\u0026amp;c.lock) panic(plainError(\u0026#34;close of closed channel\u0026#34;)) } ... } 3、读chan数据 chan关闭之后，关闭前放入的数据，仍然可以读取 已关闭的chan仍然可以读取，值为零值，返回值ok为false 如何优雅的关闭channel？\n根据 sender 和 receiver 的个数，分下面几种情况：\n一个 sender，一个 receiver 一个 sender， M 个 receiver N 个 sender，一个 reciver N 个 sender， M 个 receiver 1,2两种情况，仅一个sender，直接从sender端关闭channel即可\n第3种情况解决方案就是增加一个传递关闭信号的 channel，receiver 通过信号 channel 下达关闭数据 channel 指令。senders 监听到关闭信号后，停止发送数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func main() { rand.Seed(time.Now().UnixNano()) const Max = 100000 const NumSenders = 1000 dataCh := make(chan int, 100) stopCh := make(chan struct{}) // senders for i := 0; i \u0026lt; NumSenders; i++ { go func() { for { select { case \u0026lt;- stopCh: return case dataCh \u0026lt;- rand.Intn(Max): } } }() } // the receiver go func() { for value := range dataCh { if value == Max-1 { fmt.Println(\u0026#34;send stop signal to senders.\u0026#34;) close(stopCh) return } fmt.Println(value) } }() select { case \u0026lt;- time.After(time.Hour): } } 对于第4种情况，和第 3 种情况不同，这里有 M 个 receiver，如果直接还是采取第 3 种解决方案，由 receiver 直接关闭 stopCh 的话，就会重复关闭一个 channel，导致 panic。因此需要增加一个中间人，M 个 receiver 都向它发送关闭 dataCh 的“请求”，中间人收到第一个请求后，就会直接下达关闭 dataCh 的指令（通过关闭 stopCh，这时就不会发生重复关闭的情况，因为 stopCh 的发送方只有中间人一个）。另外，这里的 N 个 sender 也可以向中间人发送关闭 dataCh 的请求。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 func main() { rand.Seed(time.Now().UnixNano()) const Max = 100000 const NumReceivers = 10 const NumSenders = 1000 dataCh := make(chan int, 100) stopCh := make(chan struct{}) // It must be a buffered channel. toStop := make(chan string, 1) var stoppedBy string // moderator go func() { stoppedBy = \u0026lt;-toStop close(stopCh) }() // senders for i := 0; i \u0026lt; NumSenders; i++ { go func(id string) { for { value := rand.Intn(Max) if value == 0 { select { case toStop \u0026lt;- \u0026#34;sender#\u0026#34; + id: default: } return } select { case \u0026lt;- stopCh: return case dataCh \u0026lt;- value: } } }(strconv.Itoa(i)) } // receivers for i := 0; i \u0026lt; NumReceivers; i++ { go func(id string) { for { select { case \u0026lt;- stopCh: return case value := \u0026lt;-dataCh: if value == Max-1 { select { case toStop \u0026lt;- \u0026#34;receiver#\u0026#34; + id: default: } return } fmt.Println(value) } } }(strconv.Itoa(i)) } select { case \u0026lt;- time.After(time.Hour): } } ","pubDate":"2021-09-17","title":"golang里面几个chan常见的坑"},{"link":"https://caojunsheng.github.io/posts/fix-stackedit-400/","plain":"stackedit在弹出网页转到github授权界面的时候，在你点授权之前，F12打开console，输入下边的JS code：\nwindow.XMLHttpRequest = class MyXMLHttpRequest extends window.XMLHttpRequest { open(...args){ if(args[1].startsWith(\u0026#34;https://api.github.com/user?access_token=\u0026#34;)) { // apply fix as described by github // https://developer.github.com/changes/2020-02-10-deprecating-auth-through-query-param/#changes-to-make const segments = args[1].split(\u0026#34;?\u0026#34;); args[1] = segments[0]; // remove query params from url const token = segments[1].split(\u0026#34;=\u0026#34;)[1]; // save the token const ret = super.open(...args); this.setRequestHeader(\u0026#34;Authorization\u0026#34;, `token ${token}`); // set required header return ret; } else { return super.open(...args); } } } 这段代码会重写stackedit的API请求，可以成功解决400的问题，成功shouquan\nWritten with StackEdit.\n","pubDate":"0001-01-01","title":""}];
    

</script>





    </body>
</html>

