<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Chenruohan个人博客 | rpm</title>
    <meta name="description" content=" ">
    <link rel="canonical" href="https://caojunsheng.github.io/tags/rpm/" />
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <meta property="og:title" content="rpm" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://caojunsheng.github.io/tags/rpm/" />


    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="rpm"/>
<meta name="twitter:description" content=""/>

    
        
    

    
    <link rel="stylesheet" href='/css/style.css' />
    <link rel="stylesheet" href='/css/search.css' />
    <link rel="stylesheet" href='/css/list.css' />
    <link rel="stylesheet" href='/css/terms.css' />
    <link rel="stylesheet" href='/css/taxonomy.css' />
    <link rel="stylesheet" href='/css/home.css' />
    <link rel="stylesheet" href='/css/syntax.css' />
    
    <link rel="stylesheet" href='/css/shortcode.css' />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href='/css/_custom.css' />
    <style>

         
    </style>

    

    

    <script>
    MathJax = {
      tex: {
        inlineMath: [["$", "$"]],
      },
      displayMath: [
        ["$$", "$$"],
        ["\[\[", "\]\]"],
      ],
      svg: {
        fontCache: "global",
      },
    };
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script
    id="MathJax-script"
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
  ></script>



    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    
    <script src="/js/lazysizes.min.js" async=""></script>
    
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    
    <script src="/js/search.js"></script>

    <script src="/js/yes.js"></script>
    
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
</head><body style="font-family: ,'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'Heiti SC', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;">
        <div class="loading">
            <div class="loading-bg"></div>
            <div class="loading-long">
                <div class="loading-short"></div>
            </div>
        </div>
        
        <header>
    <nav class="navbar">
        
        <div class="navbar-brand">
            
            <a href="/">
                <span class="logo">Chenruohan个人博客</span>
            </a>
        </div>
        
        <div class="navbar-menu">
            
            
            <a href="/">
                <div class="menu-item">
                    <div class="hengtiao-root">
                        
                        <div class="hengtiao"></div>
                        <div class="name text-wbd-reverse"><i class='fa fa-home'></i> 首页</div>
                    </div>
                </div>
            </a>
            
            <a href="/posts">
                <div class="menu-item">
                    <div class="hengtiao-root">
                        
                        <div class="hengtiao"></div>
                        <div class="name text-wbd-reverse"><i class='fa fa-book'></i> 文章</div>
                    </div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="menu-item">
                    <div class="hengtiao-root">
                        
                        <div class="hengtiao"></div>
                        <div class="name text-wbd-reverse"><i class='fa fa-folder-open'></i> 分类</div>
                    </div>
                </div>
            </a>
            
            <a href="/series">
                <div class="menu-item">
                    <div class="hengtiao-root">
                        
                        <div class="hengtiao"></div>
                        <div class="name text-wbd-reverse"><i class='fa fa-gears'></i> 系列</div>
                    </div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="menu-item">
                    <div class="hengtiao-root">
                        
                        <div class="hengtiao"></div>
                        <div class="name text-wbd-reverse"><i class='fa fa-tags'></i> 标签</div>
                    </div>
                </div>
            </a>
            
            <a href="/about">
                <div class="menu-item">
                    <div class="hengtiao-root">
                        
                        <div class="hengtiao"></div>
                        <div class="name text-wbd-reverse"><i class='fa fa-info-circle'></i> 关于</div>
                    </div>
                </div>
            </a>
            
            
            
            <div class="navbar-burger">
                <div class="burger-btn"><span><i class="fa fa-navicon"></i></span></div>
            </div>
            <div class="search-in"><span><i class="fa fa-search"></i></span></div>
            <div class="mode">
                <span class="sun"><i class="fa fa-sun-o"></i></span>
                <span class="moon"><i class="fa fa-moon-o"></i></span>
            </div>
        </div>

    </nav>
    
    <div class="burger-items">
        
        <a href="/">
            <div class="burger-item">
                <i class='fa fa-home'></i> 首页
            </div>
        </a>
        
        <a href="/posts">
            <div class="burger-item">
                <i class='fa fa-book'></i> 文章
            </div>
        </a>
        
        <a href="/categories">
            <div class="burger-item">
                <i class='fa fa-folder-open'></i> 分类
            </div>
        </a>
        
        <a href="/series">
            <div class="burger-item">
                <i class='fa fa-gears'></i> 系列
            </div>
        </a>
        
        <a href="/tags">
            <div class="burger-item">
                <i class='fa fa-tags'></i> 标签
            </div>
        </a>
        
        <a href="/about">
            <div class="burger-item">
                <i class='fa fa-info-circle'></i> 关于
            </div>
        </a>
        
    </div>
    <div class="header-rest"></div>
      
</header>

        <div id="content">
    






    
        
    




    <div class="hero">
        
        
            
                <div class="hero-img">
                    <img src="/images/default.jpeg" alt="">
                </div>
            
        <div class="hero-content">
            
            <h1 class="hero-title">标签：rpm</h1>
        </div>
    </div>





<div class="zhuti-0">
    <div class="container">
        <div class="zhuti">
            
            <div class="zhuti-l">
                



    


<div class="terms-body">
    <div class="long">
        
        <button class="tosides-1 text-wbd">
            <i class="fa fa-arrow-right"></i>
        </button>
        <button class="tosides-2 text-wbd">
            <i class="fa fa-arrow-left"></i>
        </button>
        <button class="toup text-wbd">
            <i class="fa fa-arrow-up"></i>
        </button>
    </div>
    
        
        <div class="terms-row">
            
            <div class="terms-root">
                
                
<div class="card-large">
    <div class="card-large-img">

        
                <img data-src="/images/default.jpeg" alt="图片加载失败" class="lazyload">
        
    </div>
    <div class="card-large-content">
        <div class="up-title"><a href="https://caojunsheng.github.io/posts/linux/rpm/">rpm常用命令</a></div>
        <div class="up-date">
            <span class="no-wrap"><i class="fa fa-calendar"></i> 发布于: 2024-5-9 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-folder"></i>
                收录于:
                    
                    <a href='/categories/linux'>
                        linux
                    </a>
            </span>
        </div>
        <div class="down-summary">1.安装一个包 1 # rpm -ivh &lt; rpm package name&gt; 2.安装参数 &ndash;force 即使覆盖属于其它包的文件也强迫安装 &ndash;nodeps 如果该RPM包的安装</div>
    </div>
    <div class="card-readmore">
        <a href="https://caojunsheng.github.io/posts/linux/rpm/">
            <span><i class="fa fa-arrow-right"></i></span>
        </a>
    </div>
</div>



    


    <div class="down-type">
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='/tags/rpm'>
                    <i class="fa fa-tag"></i> rpm
                </a>
            </div>
        </span>
        
    </div>

<div class="dang"></div>
            </div>
            
        </div>

    
    
</div>



            </div>
            
            <div class="zhuti-r">
                
                
<div class="zhuti-r-0">
    
    <div class="zhuti-r-1">
        
        
        <div id="r1">
            
            <div class="about-zuozhe">
    <div class="zuozhe">
        
            <div class="datou">
                <img src="/images/author.jpeg" alt="">
            </div>
        
        <div class="name-jianjie">
            <div class="name">chenruohan</div>
            <div class="jianjie">
                人生如戏，戏如人生
            </div>
        </div>
    </div>
    <div class="type">
        <a href="/posts" class="wenzhang">
            <p>文章</p>
            <p>19</p>
        </a>
        <a href="/categories" class="fenlei">
            <p>分类</p>
            <p>8</p>
        </a>
        <a href="/tags" class="biaoqian">
            <p>标签</p>
            <p>16</p>
        </a>
    </div>
    <a href="https://github.com/caojunsheng">
        <div class="follow">Follow Me</div>
    </a>
    <div class="link">
        
        <a href="https://github.com/caojunsheng" class="link-item is-hidden-desktop" title="GitHub">
            <span class="icon"><i class='fa fa-github'></i></span>
        </a>
        
        <a href="https://www.youtube.com" class="link-item is-hidden-desktop" title="YouTube">
            <span class="icon"><i class='fa fa-youtube'></i></span>
        </a>
        
    </div>
</div>
            
            <div class="mulu">
    <div class="dong"></div>
    <div class="zhi">
        <div class="wenzi">
            <div class="zhi-mulu text-wbd">目录</div>
            <div class="mulu-items">
            </div>
        </div>
    </div>
</div>
            
            





<div class="other">
    <div class="other-up">
        <div class="other-qita text-wbd">最新文章</div>
        <div class="xian"></div>
    </div>
    <div class="list">
        
            <a href="https://caojunsheng.github.io/posts/linux/virtio/" class="">
                
<a href="https://caojunsheng.github.io/posts/linux/virtio/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/default.jpeg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                virtio_net设备初始化流程   
            </div>
            <div class="other-summary">worker_thread &ndash;&gt; process_one_work &ndash;&gt; pciehp_power_thread &ndash;&gt; pciehp_ctrl.c pciehp_enable_slot &ndash;&gt; board_added &ndash;&gt; pciehp_pci.c pciehp_configure_device &ndash;&gt; pci/bus.c pci_bus_add_devices &ndash;&gt; pci_bus_add_device &ndash;&gt; dd.c device_attach &ndash;&gt; __device_attach &ndash;&gt; bus_for_each_drv &ndash;&gt; __device_attach_driver &ndash;&gt; driver_probe_device &ndash;&gt; really_probe &ndash;&gt;call_driver_probe &ndash;&gt; pci-driver.c pci_device_probe &ndash;&gt; pci_call_probe &ndash;&gt; local_pci_probe &ndash;&gt; virtio_pci_common.c virtio_pci_probe &ndash;&gt; virtio.c register_virtio_device &ndash;&gt; core.c device_add &ndash;&gt; base/bus.c</div>
            <div class="other-date">2024年6月18日</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://caojunsheng.github.io/posts/linux/vfio-mdev/" class="">
                
<a href="https://caojunsheng.github.io/posts/linux/vfio-mdev/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/default.jpeg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                vfio-mdev使用   
            </div>
            <div class="other-summary">使用vfio-mdev 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 加载驱动 modprobe vfio_pci # 编译内</div>
            <div class="other-date">2024年6月18日</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://caojunsheng.github.io/posts/linux/virtio_blk%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE%E7%A9%BA%E9%97%B4/" class="">
                
<a href="https://caojunsheng.github.io/posts/linux/virtio_blk%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE%E7%A9%BA%E9%97%B4/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/default.jpeg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                Virtio PCI设备配置空间详解   
            </div>
            <div class="other-summary">以virtio_blk设备的配置空间为例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30</div>
            <div class="other-date">2024年5月29日</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://caojunsheng.github.io/posts/linux/aer-inject/" class="">
                
<a href="https://caojunsheng.github.io/posts/linux/aer-inject/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/default.jpeg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                PCIe aer-inject注入AER错误   
            </div>
            <div class="other-summary">对AER注入错误需要内核模块支持注入，需要安装aer_inject.ko模块，以及需要工具aer-i</div>
            <div class="other-date">2024年5月15日</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://caojunsheng.github.io/posts/virtual/libvirt%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81/" class="">
                
<a href="https://caojunsheng.github.io/posts/virtual/libvirt%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/default.jpeg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                libvirt 生成代码   
            </div>
            <div class="other-summary">背景：当我们需要修改xxx_protocol.x文件新增请求参数或者返回值参数时，又或者是需要修改自</div>
            <div class="other-date">2024年5月9日</div>
        </div>
    </div>
</a>
            </a>
        
    </div>
</div>
        </div>
        <div id="r2">
                
            
        </div> 
    </div>
</div>

            </div>
        </div>
    </div>
</div>


        </div>
        <footer class="footer">
    
        <div class="container">
            <div class="footer-items">
                
                    <div class="footer-item">
                        <i class="fa fa-user"></i> <span id="busuanzi_value_site_pv"></span> |
                        <i class="fa fa-eye"></i> <span id="busuanzi_value_site_uv"></span>
                    </div>
                
                
                    <div class="footer-item">
                        © 2022-2024 <a href="https://github.com/caojunsheng">chenruohan</a>
                    </div>
                
                
                    <div class="footer-item">
                        Theme by <a href="https://github.com/xioyito/NewBee">NewBee</a> | Powered by <a href="https://gohugo.io/">Hugo</a>
                    </div>
                
            </div>
        </div>
    
    
    
</footer>



        <div class="search-root">
    <div class="search-zz"></div>
    <div class="search">
        
        <div class="sheader anniu">
            <div class="sh-l">
                <input type="text" placeholder="输入关键字" id="search-key">
                <span class="sclear"><i class="fa fa-close"></i></span>
            </div>
            <div class="sh-r">
                <button>搜索</button>
            </div> 
        </div>

        <div class="sbody">
            <div class="sbody-1">
                <div class="stip"></div>
            </div>
            
        </div>
    </div>
</div>
        




    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    




<script type="text/javascript">
    var postsCount =  19 ;
    var arrPosts = [{"link":"https://caojunsheng.github.io/posts/linux/virtio/","plain":"worker_thread \u0026ndash;\u0026gt; process_one_work \u0026ndash;\u0026gt; pciehp_power_thread \u0026ndash;\u0026gt;\npciehp_ctrl.c\npciehp_enable_slot \u0026ndash;\u0026gt; board_added \u0026ndash;\u0026gt;\npciehp_pci.c\npciehp_configure_device \u0026ndash;\u0026gt;\npci/bus.c\npci_bus_add_devices \u0026ndash;\u0026gt; pci_bus_add_device \u0026ndash;\u0026gt;\ndd.c\ndevice_attach \u0026ndash;\u0026gt; __device_attach \u0026ndash;\u0026gt; bus_for_each_drv \u0026ndash;\u0026gt; __device_attach_driver \u0026ndash;\u0026gt; driver_probe_device \u0026ndash;\u0026gt; really_probe \u0026ndash;\u0026gt;call_driver_probe \u0026ndash;\u0026gt;\npci-driver.c\npci_device_probe \u0026ndash;\u0026gt; pci_call_probe \u0026ndash;\u0026gt; local_pci_probe \u0026ndash;\u0026gt;\nvirtio_pci_common.c\nvirtio_pci_probe \u0026ndash;\u0026gt;\nvirtio.c\nregister_virtio_device \u0026ndash;\u0026gt;\ncore.c\ndevice_add \u0026ndash;\u0026gt;\nbase/bus.c\nbus_probe_device \u0026ndash;\u0026gt;\ndd.c\ndevice_initial_probe \u0026ndash;\u0026gt; __device_attach \u0026ndash;\u0026gt; bus_for_each_drv \u0026ndash;\u0026gt; __device_attach_driver \u0026ndash;\u0026gt; driver_probe_device \u0026ndash;\u0026gt; really_probe \u0026ndash;\u0026gt;call_driver_probe \u0026ndash;\u0026gt;\nvirtio.c\nvirtio_dev_probe \u0026ndash;\u0026gt;\nvirtio_net.c\nvirtnet_probe (网卡设备驱动加载的入口)\nWritten with StackEdit.\n","pubDate":"2024-06-18","title":"virtio_net设备初始化流程"},{"link":"https://caojunsheng.github.io/posts/linux/vfio-mdev/","plain":"使用vfio-mdev 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 加载驱动 modprobe vfio_pci # 编译内核模块 cd /home/cjs/usr/src/linux-5.10.0-60.18.0.50.r1064_55.hce2.x86_64/ make modules # 编译mdev模块 make M=/home/cjs/usr/src/linux-5.10.0-60.18.0.50.r1064_55.hce2.x86_64/drivers/vfio/ -C /home/cjs/usr/src/linux-5.10.0-60.18.0.50.r1064_55.hce2.x86_64 -j10 CONFIG_VFIO_MDEV=m # 安装mdev模块 insmod mdev.ko insmod vfio_mdev.ko # 编译mdev示例设备mtty make M=/home/cjs/usr/src/linux-5.10.0-60.18.0.50.r1064_55.hce2.x86_64/samples/vfio-mdev/ -C /home/cjs/usr/src/linux-5.10.0-60.18.0.50.r1064_55.hce2.x86_64 -j10 CONFIG_SAMPLE_VFIO_MDEV_MTTY=m # 安装mtty模块 insmod mtty.ko # 创建一个mtty mdev设备 echo \u0026#34;83b8f4f2-509f-382f-3c1e-e6bfe0fa1001\u0026#34; \u0026gt; /sys/devices/virtual/mtty/mtty/mdev_supported_types/mtty-2/create # 使用该mdev设备拉起虚拟机 qemu-kvm -machine q35,accel=kvm -cpu host -smp 8 -m 16G -drive if=none,id=root,file=./centos7.2_cn.qcow2_par -device virtio-blk-pci,drive=root,disable-legacy=on -vga std -vnc :66 -device vfio-pci,addr=05.0,sysfsdev=/sys/bus/mdev/devices/83b8f4f2-509f-382f-3c1e-e6bfe0fa1001 -daemonize # 删除mtty mdev设备 echo 1 \u0026gt; /sys/bus/mdev/devices/83b8f4f2-509f-382f-3c1e-e6bfe0fa1001/remove echo \u0026ldquo;83b8f4f2-509f-382f-3c1e-e6bfe0fa1001\u0026rdquo; \u0026gt;/sys/devices/virtual/mtty/mtty/mdev_supported_types/mtty-2/create\n执行的是mdev_device_create\necho 1 \u0026gt; /sys/bus/mdev/devices/83b8f4f2-509f-382f-3c1e-e6bfe0fa1001/remove\n执行的是mdev_device_remove\n1、vfio-mdev介绍 linux官方文档：vfio-mediated-device.rst\nvfio-mdev\n全称：Virtual Function I/O (VFIO) Mediated devices\n出现的背景：NVIDIA提出的，很多设备有DMA能力，但是不支持SR_IOV，无法虚拟化出VF分割使用，但是又存在一个设备诸如GPU需要具备这种能力，需要将后端的硬件设备拆分成更小的实例给更多的vm使用。\n基于VFIO直通设备，可以在用户态通过IOMMU直通到物理设备\n+---------------+ | | | +-----------+ | mdev_register_driver() +--------------+ | | | +\u0026lt;------------------------+ | | | mdev | | | | | | bus | +------------------------\u0026gt;+ vfio_mdev.ko |\u0026lt;-\u0026gt; VFIO user | | driver | | probe()/remove() | | APIs | | | | +--------------+ | +-----------+ | | | | MDEV CORE | | MODULE | | mdev.ko | | +-----------+ | mdev_register_parent() +--------------+ | | | +\u0026lt;------------------------+ | | | | | | ccw_device.ko|\u0026lt;-\u0026gt; physical | | | +------------------------\u0026gt;+ | device | | | | callbacks +--------------+ | | Physical | | | | device | | mdev_register_parent() +--------------+ | | interface | |\u0026lt;------------------------+ | | | | | | i915.ko |\u0026lt;-\u0026gt; physical | | | +------------------------\u0026gt;+ | device | | | | callbacks +--------------+ | +-----------+ | +---------------+ 2、mdev_bus vfio_mdev中新增了一种bus_type，mdev_bus\n1 2 3 4 5 6 struct bus_type mdev_bus_type = { .name\t= \u0026#34;mdev\u0026#34;, .probe\t= mdev_probe, .remove\t= mdev_remove, .match\t= mdev_match, }; 当mdev_core加载的时候，会调用bus_register(\u0026amp;mdev_bus_type)注册这个bus，会初始化subsys_private、klist_devices和klist_drivers这两个klist，sysfs下会创建下面目录：\n1 2 3 4 5 6 /sys/bus/mdev/ ├── devices ├── drivers ├── drivers_autoprobe ├── drivers_probe └── uevent 3、设备驱动支持vfio 针对vfio模块，又定义了专门的驱动mdev_driver支持vfio\nmdev设备驱动定义\n1 2 3 4 5 6 7 8 9 10 11 12 struct mdev_driver { const char *device_api; unsigned int max_instances; // 新设备注册 int (*probe)(struct mdev_device *dev); // 删除设备 void (*remove)(struct mdev_device *dev); // 获取最大可创建的实例数 unsigned int (*get_available)(struct mdev_type *mtype); ssize_t (*show_description)(struct mdev_type *mtype, char *buf); struct device_driver driver; }; 针对于mtty示例mdev设备来说，定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 static struct mdev_driver mtty_driver = { .device_api = VFIO_DEVICE_API_PCI_STRING, .driver = { .name = \u0026#34;mtty\u0026#34;, .owner = THIS_MODULE, .mod_name = KBUILD_MODNAME, .dev_groups = mdev_dev_groups, }, .probe = mtty_probe, .remove\t= mtty_remove, .get_available = mtty_get_available, }; 当mtty设备初始化时，会调用mtty_dev_init-\u0026gt;mdev_register_driver-\u0026gt;driver_register-\u0026gt;bus_add_driver将mtty_driver驱动和上面的mdev_bus绑定起来\n在mtty_probe时，会创建vfio设备，支持vfio_device相关操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 static const struct vfio_device_ops mtty_dev_ops = { .name = \u0026#34;vfio-mtty\u0026#34;, .init = mtty_init_dev, .release = mtty_release_dev, .read = mtty_read, .write = mtty_write, .ioctl = mtty_ioctl, .bind_iommufd\t= vfio_iommufd_emulated_bind, .unbind_iommufd\t= vfio_iommufd_emulated_unbind, .attach_ioas\t= vfio_iommufd_emulated_attach_ioas, .detach_ioas\t= vfio_iommufd_emulated_detach_ioas, }; static int mtty_probe(struct mdev_device *mdev) { struct mdev_state *mdev_state; int ret; // mtty设备初始化 mdev_state = vfio_alloc_device(mdev_state, vdev, \u0026amp;mdev-\u0026gt;dev, \u0026amp;mtty_dev_ops); if (IS_ERR(mdev_state)) return PTR_ERR(mdev_state); // 注册一个模拟的iommu ret = vfio_register_emulated_iommu_dev(\u0026amp;mdev_state-\u0026gt;vdev); if (ret) goto err_put_vdev; dev_set_drvdata(\u0026amp;mdev-\u0026gt;dev, mdev_state); return 0; err_put_vdev: vfio_put_device(\u0026amp;mdev_state-\u0026gt;vdev); return ret; } 设备初始化时会注册驱动到mdev_bus上。\n1 2 3 4 5 6 7 8 9 10 # 注册mdev设备驱动 int mdev_register_driver(struct mdev_driver *drv) { if (!drv-\u0026gt;device_api) return -EINVAL; /* initialize common driver fields */ drv-\u0026gt;driver.bus = \u0026amp;mdev_bus_type; // 设置驱动的bus为mdev_bus return driver_register(\u0026amp;drv-\u0026gt;driver); } 在调用bus_add_driver时，主要是初始化driver_private，并将该driver挂到mdev_bus的klist_drivers上，然后创建drivers目录下相关sysfs目录\n1 2 3 4 5 6 7 8 9 10 11 /sys/bus/mdev/ ├── devices ├── drivers │ └── vfio_mdev │ ├── bind │ ├── module -\u0026gt; ../../../../module/vfio_mdev │ ├── uevent │ └── unbind ├── drivers_autoprobe ├── drivers_probe └── uevent 去注册mdev设备驱动\nvoid mdev_unregister_driver(struct mdev_driver *drv);\n4、设备适配mdev框架 mdev设备驱动需要做的事：\nconfig space、bar region、PCIe cap mmio访问 dma 中断 设备除了要实现上述功能外，还需要将自身注册为虚拟设备的父设备，通过mdev_register_parent来实现。\n注册父设备\nint mdev_register_parent(struct mdev_parent *parent, struct device *dev, struct mdev_driver *mdev_driver, struct mdev_type **types, unsigned int nr_types); 去注册父设备\nvoid mdev_unregister_parent(struct mdev_parent *parent); 并在sysfs下给parent创建相应的目录\n/sys/devices/virtual/mtty/mtty/ ├── 83b8f4f2-509f-382f-3c1e-e6bfe0fa1001 │ ├── driver -\u0026gt; ../../../../../bus/mdev/drivers/vfio_mdev │ ├── iommu_group -\u0026gt; ../../../../../kernel/iommu_groups/0 │ ├── mdev_type -\u0026gt; ../mdev_supported_types/mtty-2 │ ├── power │ │ ├── autosuspend_delay_ms │ │ ├── control │ │ ├── runtime_active_time │ │ ├── runtime_status │ │ └── runtime_suspended_time │ ├── remove │ ├── subsystem -\u0026gt; ../../../../../bus/mdev │ ├── uevent │ └── vendor │ └── sample_mdev_dev ├── mdev_supported_types │ ├── mtty-1 │ │ ├── available_instances │ │ ├── create │ │ ├── device_api │ │ ├── devices │ │ └── name │ └── mtty-2 │ ├── available_instances │ ├── create │ ├── device_api │ ├── devices │ │ └── 83b8f4f2-509f-382f-3c1e-e6bfe0fa1001 -\u0026gt; ../../../83b8f4f2-509f-382f-3c1e-e6bfe0fa1001 │ └── name ├── mtty_dev │ └── sample_mtty_dev ├── power │ ├── autosuspend_delay_ms │ ├── control │ ├── runtime_active_time │ ├── runtime_status │ └── runtime_suspended_time ├── subsystem -\u0026gt; ../../../../class/mtty └── uevent 5、如何创建可以直通给vm的mdev设备 原先SRIOV场景下需要把设备从原有驱动unbind，再bind到vfio-pci驱动上，而mdev设备则是通过sysfs在用户空间创建mdev设备\n在执行echo \u0026quot;83b8f4f2-509f-382f-3c1e-e6bfe0fa1001\u0026quot; \u0026gt; /sys/devices/virtual/mtty/mtty/mdev_supported_types/mtty-2/create之后会执行create_store\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 static ssize_t create_store(struct mdev_type *mtype, struct mdev_type_attribute *attr, const char *buf, size_t count) { char *str; guid_t uuid; int ret; if ((count \u0026lt; UUID_STRING_LEN) || (count \u0026gt; UUID_STRING_LEN + 1)) return -EINVAL; str = kstrndup(buf, count, GFP_KERNEL); if (!str) return -ENOMEM; // 解析guid ret = guid_parse(str, \u0026amp;uuid); kfree(str); if (ret) return ret; ret = mdev_device_create(mtype, \u0026amp;uuid); if (ret) return ret; return count; } static MDEV_TYPE_ATTR_WO(create); create_store只是sysfs里面定义封装的入口，紧接着会调用真实创建设备的mdev_device_create\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 // echo guid到create文件之后创建mdev设备 int mdev_device_create(struct mdev_type *type, const guid_t *uuid) { int ret; struct mdev_device *mdev, *tmp; struct mdev_parent *parent = type-\u0026gt;parent; struct mdev_driver *drv = parent-\u0026gt;mdev_driver; mutex_lock(\u0026amp;mdev_list_lock); /* Check for duplicate */ // 遍历mdev_list，检查是否已存在相同uuid的mdev list_for_each_entry(tmp, \u0026amp;mdev_list, next) { if (guid_equal(\u0026amp;tmp-\u0026gt;uuid, uuid)) { mutex_unlock(\u0026amp;mdev_list_lock); return -EEXIST; } } if (!drv-\u0026gt;get_available) { /* * Note: that non-atomic read and dec is fine here because * all modifications are under mdev_list_lock. */ if (!atomic_read(\u0026amp;parent-\u0026gt;available_instances)) { mutex_unlock(\u0026amp;mdev_list_lock); return -EUSERS; } // 减少可用实例数 atomic_dec(\u0026amp;parent-\u0026gt;available_instances); } mdev = kzalloc(sizeof(*mdev), GFP_KERNEL); if (!mdev) { mutex_unlock(\u0026amp;mdev_list_lock); return -ENOMEM; } // mdev设备初始化 device_initialize(\u0026amp;mdev-\u0026gt;dev); // 设置mdev设备父设备 mdev-\u0026gt;dev.parent = parent-\u0026gt;dev; // 设置mdev设备总线类型 mdev-\u0026gt;dev.bus = \u0026amp;mdev_bus_type; mdev-\u0026gt;dev.release = mdev_device_release; // groups用来创建sysfs文件 mdev-\u0026gt;dev.groups = mdev_device_groups; mdev-\u0026gt;type = type; /* Pairs with the put in mdev_device_release() */ kobject_get(\u0026amp;type-\u0026gt;kobj); // 设置mdev设备的uuid guid_copy(\u0026amp;mdev-\u0026gt;uuid, uuid); list_add(\u0026amp;mdev-\u0026gt;next, \u0026amp;mdev_list); mutex_unlock(\u0026amp;mdev_list_lock); ret = dev_set_name(\u0026amp;mdev-\u0026gt;dev, \u0026#34;%pUl\u0026#34;, uuid); if (ret) goto out_put_device; /* Check if parent unregistration has started */ if (!down_read_trylock(\u0026amp;parent-\u0026gt;unreg_sem)) { ret = -ENODEV; goto out_put_device; } // 添加mdev设备 ret = device_add(\u0026amp;mdev-\u0026gt;dev); if (ret) goto out_unlock; // 设备绑定到mdev驱动 ret = device_driver_attach(\u0026amp;drv-\u0026gt;driver, \u0026amp;mdev-\u0026gt;dev); if (ret) goto out_del; ret = mdev_create_sysfs_files(mdev); if (ret) goto out_del; mdev-\u0026gt;active = true; dev_dbg(\u0026amp;mdev-\u0026gt;dev, \u0026#34;MDEV: created\\n\u0026#34;); up_read(\u0026amp;parent-\u0026gt;unreg_sem); return 0; out_del: device_del(\u0026amp;mdev-\u0026gt;dev); out_unlock: up_read(\u0026amp;parent-\u0026gt;unreg_sem); out_put_device: put_device(\u0026amp;mdev-\u0026gt;dev); return ret; } 创建后会一路调用到mdev_driver mtty_driver的probe，调用顺序：mdev_device_create-\u0026gt;device_driver_attach-\u0026gt;__driver_probe_device-\u0026gt;really_probe-\u0026gt;call_driver_probe-\u0026gt;mdev_bus_type.probe-\u0026gt;mtty_driver.probe\n1 2 3 4 5 6 7 8 9 10 // mdev probe实现比较简单，直接调用mdev_driver.probe static int mdev_probe(struct device *dev) { struct mdev_driver *drv = container_of(dev-\u0026gt;driver, struct mdev_driver, driver); if (!drv-\u0026gt;probe) return 0; return drv-\u0026gt;probe(to_mdev_device(dev)); } mdev注册了一个模拟的iommu group，类型为VFIO_EMULATED_IOMMU\nmtty_probe-\u0026gt;vfio_register_emulated_iommu_dev-\u0026gt;__vfio_register_dev-\u0026gt;vfio_device_set_group-\u0026gt;vfio_noiommu_group_alloc-\u0026gt;vfio_create_group-\u0026gt;vfio_group_alloc-\u0026gt;vfio_group_fops.unlocked_ioctl-\u0026gt;vfio_group_ioctl_set_container-\u0026gt;vfio_iommu_driver_ops_type1.vfio_iommu_type1_attach_group\n由于mdev设备硬件没有IOMMU能力，所以需要软件模拟IOMMU功能，参考vfio_iommu.emulated_iommu_groups实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 struct vfio_iommu { struct list_head\tdomain_list; struct list_head\tiova_list; struct mutex\tlock; struct rb_root\tdma_list; struct list_head\tdevice_list; struct mutex\tdevice_list_lock; unsigned int\tdma_avail; unsigned int\tvaddr_invalid_count; uint64_t\tpgsize_bitmap; uint64_t\tnum_non_pinned_groups; bool\tv2; bool\tnesting; bool\tdirty_page_tracking; struct list_head\temulated_iommu_groups; // }; // mdev设备无法做dma map static int vfio_dma_do_map(struct vfio_iommu *iommu, struct vfio_iommu_type1_dma_map *map) { …… /* Don\u0026#39;t pin and map if container doesn\u0026#39;t contain IOMMU capable domain*/ if (list_empty(\u0026amp;iommu-\u0026gt;domain_list)) dma-\u0026gt;size = size; else ret = vfio_pin_map_dma(iommu, dma, size); } // mdev设备同样不支持unmap static int vfio_dma_do_unmap(struct vfio_iommu *iommu, struct vfio_iommu_type1_dma_unmap *unmap, struct vfio_bitmap *bitmap) { …… /* Cannot update vaddr if mdev is present. */ if (invalidate_vaddr \u0026amp;\u0026amp; !list_empty(\u0026amp;iommu-\u0026gt;emulated_iommu_groups)) { ret = -EBUSY; goto unlock; } } 聊聊vfio mdev工作原理 · kernelnote\nVFIO Part II. VFIO-mdev | tcbbd的博客\nWritten with StackEdit.\n","pubDate":"2024-06-18","title":"vfio-mdev使用"},{"link":"https://caojunsheng.github.io/posts/linux/virtio_blk%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE%E7%A9%BA%E9%97%B4/","plain":"以virtio_blk设备的配置空间为例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 # lspci -vvvvs 31:00.7 31:00.7 Class fe01: Virtio: Virtio block device (prog-if 30) Subsystem: Virtio: Device 0002 Physical Slot: 2 Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr+ Stepping- SERR+ FastB2B- DisINTx+ Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast \u0026gt;TAbort- \u0026lt;TAbort- \u0026lt;MAbort- \u0026gt;SERR- \u0026lt;PERR- INTx+ Latency: 0, Cache Line Size: 32 bytes NUMA node: 0 Region 0: Memory at 9c816000 (32-bit, prefetchable) [size=8K] Region 1: Memory at 9c821000 (32-bit, non-prefetchable) [size=4K] Region 2: Memory at 9c7e8000 (32-bit, prefetchable) [size=32K] Region 3: Memory at 9c730000 (32-bit, non-prefetchable) [size=64K] Region 4: Memory at d2ff4800000 (64-bit, prefetchable) [size=4M] Expansion ROM at 9bf00000 [disabled] [size=1M] Capabilities: [40] Express (v2) Endpoint, MSI 00 DevCap:\tMaxPayload 512 bytes, PhantFunc 0, Latency L0s unlimited, L1 unlimited ExtTag+ AttnBtn- AttnInd- PwrInd- RBE+ FLReset+ SlotPowerLimit 0.000W DevCtl:\tCorrErr+ NonFatalErr+ FatalErr+ UnsupReq- RlxdOrd+ ExtTag+ PhantFunc- AuxPwr- NoSnoop+ FLReset- MaxPayload 512 bytes, MaxReadReq 4096 bytes DevSta:\tCorrErr+ NonFatalErr- FatalErr- UnsupReq+ AuxPwr- TransPend- LnkCap:\tPort #0, Speed 16GT/s, Width x8, ASPM not supported ClockPM- Surprise- LLActRep- BwNot- ASPMOptComp+ LnkCtl:\tASPM Disabled; RCB 64 bytes Disabled- CommClk- ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt- LnkSta:\tSpeed 16GT/s (ok), Width x8 (ok) TrErr- Train- SlotClk- DLActive- BWMgmt- ABWMgmt- DevCap2: Completion Timeout: Not Supported, TimeoutDis-, NROPrPrP-, LTR- 10BitTagComp-, 10BitTagReq-, OBFF Not Supported, ExtFmt+, EETLPPrefix- EmergencyPowerReduction Not Supported, EmergencyPowerReductionInit- FRS-, TPHComp-, ExtTPHComp- AtomicOpsCap: 32bit- 64bit- 128bitCAS- DevCtl2: Completion Timeout: 50us to 50ms, TimeoutDis-, LTR-, OBFF Disabled AtomicOpsCtl: ReqEn+ LnkSta2: Current De-emphasis Level: -6dB, EqualizationComplete-, EqualizationPhase1- EqualizationPhase2-, EqualizationPhase3-, LinkEqualizationRequest- Capabilities: [80] MSI: Enable- Count=1/2 Maskable+ 64bit+ Address: 0000000000000000 Data: 0000 Masking: 00000000 Pending: 00000000 Capabilities: [98] Vital Product Data Product Name: Read-only fields: [PN] Part number: 970, NIC, 2X100GE End Capabilities: [a0] MSI-X: Enable+ Count=2 Masked- Vector table: BAR=2 offset=00000000 PBA: BAR=2 offset=00004000 Capabilities: [b0] Power Management version 3 Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0+,D1+,D2+,D3hot+,D3cold+) Status: D0 NoSoftRst+ PME-Enable- DSel=0 DScale=0 PME- Capabilities: [b8] Vendor Specific Information: VirtIO: CommonCfg BAR=1 offset=00000f00 size=00000038 Capabilities: [c8] Vendor Specific Information: VirtIO: Notify BAR=1 offset=00000ff0 size=00000004 multiplier=00000000 Capabilities: [dc] Vendor Specific Information: VirtIO: ISR BAR=1 offset=00000f3c size=00000004 Capabilities: [ec] Vendor Specific Information: VirtIO: DeviceCfg BAR=1 offset=00000f40 size=00000050 Capabilities: [100 v2] Advanced Error Reporting UESta:\tDLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq+ ACSViol- UEMsk:\tDLP- SDES- TLP+ FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq+ ACSViol- UESvrt:\tDLP+ SDES+ TLP- FCP+ CmpltTO- CmpltAbrt- UnxCmplt- RxOF+ MalfTLP+ ECRC- UnsupReq- ACSViol- CESta:\tRxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr+ CEMsk:\tRxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr- AERCap:\tFirst Error Pointer: 00, ECRCGenCap+ ECRCGenEn- ECRCChkCap+ ECRCChkEn- MultHdrRecCap- MultHdrRecEn- TLPPfxPres- HdrLogCap+ HeaderLog: 00000000 00000000 00000000 00000000 Capabilities: [150 v1] Alternative Routing-ID Interpretation (ARI) ARICap:\tMFVC- ACS-, Next Function: 8 ARICtl:\tMFVC- ACS-, Function Group: 0 Capabilities: [200 v1] Single Root I/O Virtualization (SR-IOV) IOVCap:\tMigration-, Interrupt Message Number: 000 IOVCtl:\tEnable+ Migration- Interrupt- MSE+ ARIHierarchy- IOVSta:\tMigration- Initial VFs: 255, Total VFs: 255, Number of VFs: 255, Function Dependency Link: 07 VF offset: 1144, stride: 1, Device ID: 1001 Supported Page Size: 00000553, System Page Size: 00000001 Region 0: Memory at 00000d2ffd70c000 (64-bit, prefetchable) Region 2: Memory at 00000d2ff97f0000 (64-bit, prefetchable) Region 4: Memory at 00000d2ffd310000 (64-bit, prefetchable) VF Migration: offset: 00000000, BIR: 0 Capabilities: [2a0 v1] Transaction Processing Hints Device specific mode supported No steering table available Capabilities: [4e0 v1] Device Serial Number ff-ff-ff-ff-ff-ff-ff-ff Capabilities: [630 v1] Access Control Services ACSCap:\tSrcValid- TransBlk- ReqRedir- CmpltRedir- UpstreamFwd- EgressCtrl- DirectTrans- ACSCtl:\tSrcValid- TransBlk- ReqRedir- CmpltRedir- UpstreamFwd- EgressCtrl- DirectTrans- Capabilities: [700 v1] Data Link Feature \u0026lt;?\u0026gt; Kernel driver in use: virtio-pci Kernel modules: virtio_pci lspci -xxxs 31:00.7\n31:00.7 Class fe01: Virtio: Virtio block device\n00: f4 1a 01 10 46 05 18 00 00 30 01 fe 08 00 80 00\n10: 08 60 81 9c 00 10 82 9c 08 80 7e 9c 00 00 73 9c\n20: 0c 00 80 f4 2f 0d 00 00 00 00 00 00 f4 1a 02 00\n30: 00 00 f0 9b 40 00 00 00 00 00 00 00 ff 00 00 00\n// #define PCI_CAP_ID_EXP\t0x10\t/* PCI Express */\n40: 10 80 02 00 e2 8f 00 10 57 59 09 00 84 f0 43 00\n50: 00 00 84 00 00 00 00 00 00 00 00 00 00 00 00 00\n60: 00 00 00 00 00 00 10 00 40 00 00 00 3e 3e 80 01\n70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n// #define PCI_CAP_ID_MSI\t0x05\t/* Message Signalled Interrupts */\n80: 05 98 82 01 00 00 00 00 00 00 00 00 00 00 00 00\n// #define PCI_CAP_ID_VPD\t0x03\t/* Vital Product Data */\n90: 00 00 00 00 00 00 00 00 03 a0 18 80 30 47 45 78\n// #define PCI_CAP_ID_MSIX\t0x11\t/* MSI-X */\na0: 11 b0 01 80 02 00 00 00 02 40 00 00 00 00 00 00\n//#define PCI_CAP_ID_PM\t0x01\t/* Power Management */\n//#define PCI_CAP_ID_VNDR\t0x09\t/* Vendor-Specific */\nb0: 01 b8 03 f8 08 00 00 00 09 c8 10 01 01 00 00 00\nc0: 00 0f 00 00 38 00 00 00 09 dc 14 02 01 00 00 00\nd0: f0 0f 00 00 04 00 00 00 00 00 00 00 09 ec 10 03\ne0: 01 00 00 00 3c 0f 00 00 04 00 00 00 09 00 10 04\nf0: 01 00 00 00 40 0f 00 00 50 00 00 00 00 00 00 00\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // PCI Capabilities ID枚举 #define PCI_CAP_ID_PM\t0x01\t/* Power Management */ #define PCI_CAP_ID_AGP\t0x02\t/* Accelerated Graphics Port */ #define PCI_CAP_ID_VPD\t0x03\t/* Vital Product Data */ #define PCI_CAP_ID_SLOTID\t0x04\t/* Slot Identification */ #define PCI_CAP_ID_MSI\t0x05\t/* Message Signalled Interrupts */ #define PCI_CAP_ID_CHSWP\t0x06\t/* CompactPCI HotSwap */ #define PCI_CAP_ID_PCIX\t0x07\t/* PCI-X */ #define PCI_CAP_ID_HT\t0x08\t/* HyperTransport */ #define PCI_CAP_ID_VNDR\t0x09\t/* Vendor-Specific */ #define PCI_CAP_ID_DBG\t0x0A\t/* Debug port */ #define PCI_CAP_ID_CCRC\t0x0B\t/* CompactPCI Central Resource Control */ #define PCI_CAP_ID_SHPC\t0x0C\t/* PCI Standard Hot-Plug Controller */ #define PCI_CAP_ID_SSVID\t0x0D\t/* Bridge subsystem vendor/device ID */ #define PCI_CAP_ID_AGP3\t0x0E\t/* AGP Target PCI-PCI bridge */ #define PCI_CAP_ID_SECDEV\t0x0F\t/* Secure Device */ #define PCI_CAP_ID_EXP\t0x10\t/* PCI Express */ #define PCI_CAP_ID_MSIX\t0x11\t/* MSI-X */ #define PCI_CAP_ID_SATA\t0x12\t/* SATA Data/Index Conf. */ #define PCI_CAP_ID_AF\t0x13\t/* PCI Advanced Features */ #define PCI_CAP_ID_EA\t0x14\t/* PCI Enhanced Allocation */ // virtio_pci_cap结构体定义 struct virtio_pci_cap { __u8 cap_vndr;\t/* Generic PCI field: PCI_CAP_ID_VNDR */ __u8 cap_next;\t/* Generic PCI field: next ptr. */ __u8 cap_len;\t/* Generic PCI field: capability length */ __u8 cfg_type;\t/* Identifies the structure. */ __u8 bar;\t/* Where to find it. */ __u8 id;\t/* Multiple capabilities of the same type */ __u8 padding[2];\t/* Pad to full dword. */ __le32 offset;\t/* Offset within bar. */ __le32 length;\t/* Length of the structure, in bytes. */ }; // cfg_type枚举类型 /* Common configuration */ #define VIRTIO_PCI_CAP_COMMON_CFG\t1 /* Notifications */ #define VIRTIO_PCI_CAP_NOTIFY_CFG\t2 /* ISR access */ #define VIRTIO_PCI_CAP_ISR_CFG\t3 /* Device specific configuration */ #define VIRTIO_PCI_CAP_DEVICE_CFG\t4 /* PCI configuration access */ #define VIRTIO_PCI_CAP_PCI_CFG\t5 /* Additional shared memory capability */ #define VIRTIO_PCI_CAP_SHARED_MEMORY_CFG 8 以c8起始的Capabilities为例，逐个解析\nCapabilities: [c8] Vendor Specific Information: VirtIO: Notify\nBAR=1 offset=00000ff0 size=00000004 multiplier=00000000\nc0: 00 0f 00 00 38 00 00 00 09 dc 14 02 01 00 00 00\nd0: f0 0f 00 00 04 00 00 00 00 00 00 00 09 ec 10 03\n配置空间值 对应字段 实际含义 09 __u8 cap_vndr PCI_CAP_ID_VNDR：Vendor-Specific dc __u8 cap_next 指向下一个指针起始位置 14 __u8 cap_len Capabilities长度 02 __u8 cfg_type VIRTIO_PCI_CAP_NOTIFY_CFG 01 __u8 bar BAR=1 00 __u8 id 相同类型的Capabilities的id标识 00 00 __u8 padding[2] f0 0f 00 00 __le32 offset 偏移位置 04 00 00 00 __le32 length 大小 Written with StackEdit.\n","pubDate":"2024-05-29","title":"Virtio PCI设备配置空间详解"},{"link":"https://caojunsheng.github.io/posts/linux/aer-inject/","plain":"对AER注入错误需要内核模块支持注入，需要安装aer_inject.ko模块，以及需要工具aer-inject命令行工具\n1、编译出aer_inject.ko 1 2 3 4 #编译ko模块 make M=/mnt/cjs/kernel/usr/src/linux-4.19.90-vhulk2202.2.0.h1064.aarch64/drivers/pci/pcie -C /lib/modules/4.19.90-vhulk2202.2.0.h1064.aarch64/build/ -j10 CONFIG_PCIEAER_INJECT=m #安装ko模块 insmod aer_inject.ko 安装成功后，能够在dev设备下看到aer_inject\n1 2 # ll /dev/aer_inject crw------- 1 root root 10, 51 May 15 10:14 /dev/aer_inject 2、获取aer-inject aer错误注入工具 1 2 3 git clone https://github.com/jderrick/aer-inject.git cd aer-inject make 3、aer错误注入 执行下面命令注入错误，这个代表针对08:0e.0设备注入不可校正的SURPDN（Surprise Down Error）错误\n./aer-inject -s 08:0e.0 examples/fatal\nexamples/fatal文件\n1 2 3 4 AER # PCI_ID [WWWW:]XX.YY.Z UNCOR_STATUS SURPDN HEADER_LOG 0 1 2 4 3.1 先屏蔽AER错误，观察是否正常注入错误 由于该设备不可校正错误掩码寄存器中将SDES置为1，所以将该错误屏蔽了，从/var/log/message中日志也可以看出。\n1 2 3 4 5 6 7 8 9 Capabilities: [100 v1] Advanced Error Reporting UESta:\tDLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol- UEMsk:\tDLP- SDES+ TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol- UESvrt:\tDLP+ SDES+ TLP- FCP+ CmpltTO- CmpltAbrt- UnxCmplt- RxOF+ MalfTLP+ ECRC- UnsupReq- ACSViol- CESta:\tRxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr- CEMsk:\tRxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr+ AERCap:\tFirst Error Pointer: 00, ECRCGenCap+ ECRCGenEn- ECRCChkCap+ ECRCChkEn- MultHdrRecCap- MultHdrRecEn- TLPPfxPres- HdrLogCap- HeaderLog: 00000000 00000000 00000000 00000000 /var/log/message日志\n1 2 2024-05-15T14:57:36.877516+08:00|warning|kernel[-]|[17763.652315] pci 0000:08:0e.0: aer_inject: The uncorrectable error(s) is masked by device 2024-05-15T14:57:36.887546+08:00|notice|[/bin/bash]|[2024-05-15 14:57:36 root ./aer-inject -s 08:0e.0 examples/fatal] return code=[255], execute failed by [root(uid=0)] from [pts/0 (52.170.130.96)] 3.2 不屏蔽AER错误，观察是否正常注入错误 通过setpci将该掩码SDES置为0，取消错误屏蔽\nsetpci -s 08:0e.0 100+08.L=00400000\n再执行aer错误注入\n./aer-inject -s 08:0e.0 examples/fatal\n会发现该设备已出现错误，故障注入成功\n1 2 3 # lspci -vvs 08:0e.0 08:0e.0 PCI bridge: xxx Device (rev ff) (prog-if ff) !!! Unknown header type 7f 后续没有找到恢复该设备的方法，重置设备报错echo 1 \u0026gt; /sys/bus/pci/devices/\u0026lt;device_bus_id\u0026gt;/reset，只能重启恢复\nWritten with StackEdit.\n","pubDate":"2024-05-15","title":"PCIe aer-inject注入AER错误"},{"link":"https://caojunsheng.github.io/posts/virtual/libvirt%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81/","plain":" 背景：当我们需要修改xxx_protocol.x文件新增请求参数或者返回值参数时，又或者是需要修改自动生成出的代码时（gendispatch.pl），想先本地看看生成出的代码是否符合预期时，可以先在本地执行生成代码的操作，避免上环境编译才能得到生成代码。\n1、RPC文件定义 当前存在下面三种RPC文件定义\nsrc/remote/remote_protocol.x src/remote/lxc_protocol.x src/remote/qemu_protocol.x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // remote_protocol.x …… // 一些常量定义和结构体定义 const REMOTE_STRING_MAX = 4194304; typedef string remote_nonnull_string\u0026lt;REMOTE_STRING_MAX\u0026gt;; typedef remote_nonnull_string *remote_string; …… // 请求携带的参数 struct remote_connect_supports_feature_args { int feature; }; // 返回值携带的参数 struct remote_connect_supports_feature_ret { int supported; }; …… // 远程调用方法的序号 enum remote_procedure { REMOTE_PROC_CONNECT_OPEN = 1, REMOTE_PROC_CONNECT_CLOSE = 2, …… } 2、perl生成代码文件 src/rpc/gendispatch.pl支持生成client和server两种代码\n1 2 3 4 # Bodies for dispatch functions (\u0026#34;remote_dispatch.h\u0026#34;). elsif ($mode eq \u0026#34;server\u0026#34;) # Bodies for client functions (\u0026#34;remote_client_bodies.h\u0026#34;). elsif ($mode eq \u0026#34;client\u0026#34;) 通过Makefile自动生成client和server代码\nsrc/remote/Makefile.inc.am\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 remote/remote_client_bodies.h: $(srcdir)/rpc/gendispatch.pl \\ $(REMOTE_PROTOCOL) Makefile.am $(AM_V_GEN)$(PERL) -w $(srcdir)/rpc/gendispatch.pl --mode=client \\ remote REMOTE $(REMOTE_PROTOCOL) \\ \u0026gt; remote/remote_client_bodies.h remote/lxc_client_bodies.h: $(srcdir)/rpc/gendispatch.pl \\ $(LXC_PROTOCOL) Makefile.am $(AM_V_GEN)$(PERL) -w $(srcdir)/rpc/gendispatch.pl --mode=client \\ lxc LXC $(LXC_PROTOCOL) \\ \u0026gt; remote/lxc_client_bodies.h remote/qemu_client_bodies.h: $(srcdir)/rpc/gendispatch.pl \\ $(QEMU_PROTOCOL) Makefile.am $(AM_V_GEN)$(PERL) -w $(srcdir)/rpc/gendispatch.pl --mode=client \\ qemu QEMU $(QEMU_PROTOCOL) \\ \u0026gt; remote/qemu_client_bodies.h remote/remote_daemon_dispatch_stubs.h: $(srcdir)/rpc/gendispatch.pl \\ $(REMOTE_PROTOCOL) Makefile.am $(AM_V_GEN)$(PERL) -w $(top_srcdir)/src/rpc/gendispatch.pl \\ --mode=server remote REMOTE $(REMOTE_PROTOCOL) \\ \u0026gt; remote/remote_daemon_dispatch_stubs.h remote/lxc_daemon_dispatch_stubs.h: $(srcdir)/rpc/gendispatch.pl \\ $(LXC_PROTOCOL) Makefile.am $(AM_V_GEN)$(PERL) -w $(top_srcdir)/src/rpc/gendispatch.pl \\ --mode=server lxc LXC $(LXC_PROTOCOL) \\ \u0026gt; remote/lxc_daemon_dispatch_stubs.h remote/qemu_daemon_dispatch_stubs.h: $(srcdir)/rpc/gendispatch.pl \\ $(QEMU_PROTOCOL) Makefile.am $(AM_V_GEN)$(PERL) -w $(top_srcdir)/src/rpc/gendispatch.pl \\ --mode=server qemu QEMU $(QEMU_PROTOCOL) \\ \u0026gt; remote/qemu_daemon_dispatch_stubs.h 上面可以再Makefile里面生成，自然也可以通过perl在本地生成。\n生成文件前需要再本地安装perl，perl安装外网可搜一篇通用安装教程。\n参考上面的Makefile，可以得到下面的生成命令\n1 2 3 4 5 6 7 8 9 10 11 12 # 生成remote_client_bodies.h文件 perl -w gendispatch.pl --mode=client remote REMOTE ../remote/remote_protocol.x \u0026gt; ../remote/remote_client_bodies.h # 生成lxc_client_bodies.h文件 perl -w gendispatch.pl --mode=client lxc LXC ../remote/lxc_protocol.x \u0026gt; ../remote/lxc_client_bodies.h # 生成qemu_client_bodies.h文件 perl -w gendispatch.pl --mode=client qemu QEMU ../remote/qemu_protocol.x \u0026gt; ../remote/qemu_client_bodies.h # 生成remote_daemon_dispatch_stubs.h文件 perl -w gendispatch.pl --mode=server remote REMOTE ../remote/remote_protocol.x \u0026gt; ../remote/remote_daemon_dispatch_stubs.h # 生成lxc_daemon_dispatch_stubs.h文件 perl -w gendispatch.pl --mode=server lxc LXC ../remote/lxc_protocol.x \u0026gt; ../remote/lxc_daemon_dispatch_stubs.h # 生成qemu_daemon_dispatch_stubs.h文件 perl -w gendispatch.pl --mode=server qemu QEMU ../remote/qemu_protocol.x \u0026gt; ../remote/qemu_daemon_dispatch_stubs.h Written with StackEdit.\n","pubDate":"2024-05-09","title":"libvirt 生成代码"},{"link":"https://caojunsheng.github.io/posts/linux/gdb/","plain":"相关命令：\nr（run）：运行\nq（quit）：退出\nb（break）：打断点\n• b function_name • b row_num • b file_name:row_num • b row_num if condition c（continue）：继续执行\nprint $xx：打印具体变量\nwatch $xx：监控一个对象\n(gdb) rwatch num 当要观察的变量num被读时，程序暂停运行\n(gdb) awatch num 当要观察的变量num被读或被写，程序暂停运行\n(gdb) info watchpoints 查看当前设置的所有观察点\ndisable $num：禁用断点\nd $num（delete）：删除断点\nn（next）：单步执行\ns（step）：跳入一个函数\nfinish：跳出函数\nwhatis $xx：查看变量类型\nwinheight：启动可视化调试\nbt ：bt是 backtrace 指令的缩写，显示所有的函数调用栈的信息，栈中的每个函数都被分配了一个编号，最近被调用的函数在 0 号帧中（栈顶），并且每个帧占用一行。\nbt n ：显示函数调用栈从栈顶算起的n帧信息（n 表示一个正整数）。\nbt -n ：显示函数调用栈从栈底算起的n帧信息。\nbt full ：显示栈中所有信息如：函数参数，本地变量等。\nbt full n ：显示函数调用栈从栈顶算起的n帧的所有信息。\nbt full -n ：显示函数调用栈从栈底算起的n帧的所有信息。\nset print pretty on：格式化打印\n连续输出数组\n(gdb) set print array-indexes on\n输出index从0开始共十个\n(gdb) p buffer[0]@10\nWritten with StackEdit.\n","pubDate":"2024-05-09","title":"gdb常用命令"},{"link":"https://caojunsheng.github.io/posts/linux/rpm/","plain":"1.安装一个包 1 # rpm -ivh \u0026lt; rpm package name\u0026gt; 2.安装参数 \u0026ndash;force 即使覆盖属于其它包的文件也强迫安装 \u0026ndash;nodeps 如果该RPM包的安装依赖其它包，即使其它包没装，也强迫安装。\n3.升级一个包 1 # rpm -Uvh \u0026lt; rpm package name\u0026gt; 4.移除一个包 1 # rpm -e \u0026lt; rpm package name\u0026gt; 5.查询一个包是否被安装 1 # rpm -q \u0026lt; rpm package name\u0026gt; 6.得到被安装的包的信息 1 # rpm -qi \u0026lt; rpm package name\u0026gt; 7.列出该包中有哪些库和头文件 1 # rpm -ql \u0026lt; rpm package name\u0026gt; 8.列出服务器上的一个文件属于哪一个RPM包 1 #rpm -qf + 文件名 9.可综合好几个参数一起用 1 # rpm -qil \u0026lt; rpm package name\u0026gt; 10.列出所有被安装的rpm package 1 # rpm -qa 11.列出一个RPM包文件中包含有哪些文件 1 # rpm -qlp \u0026lt; rpm package name\u0026gt; 12.解压一个rpm包 1 # rpm2cpio xxx.rpm | cpio -idm 13.批量解压当前目录所有rpm包 1 find . -type f -print0 | xargs -0 -I x sh -c \u0026#39;rpm2cpio x | cpio -idm\u0026#39; Written with StackEdit.\n","pubDate":"2024-05-09","title":"rpm常用命令"},{"link":"https://caojunsheng.github.io/posts/linux/common-cmd/","plain":"1、rpm文件解压命令\n1 rpm2cpio filename | cpio -div 2、yum一次性删除多个rpm包\nyum list --installed|grep xxx|awk '{print $1}'|xargs yum remove -y 3、批量解压当前目录所有rpm包\n1 find . -type f -print0 | xargs -0 -I x sh -c \u0026#39;rpm2cpio x | cpio -idm\u0026#39; 4、查看全部的vsock连接\n1 # ss -a --vsock -p 5、解压initrd文件\nmv initrd initrd.gz \u0026amp;\u0026amp; gunzip initrd.gz \u0026amp;\u0026amp; cpio -i \u0026lt; initrd\n将解压后的initrd合成initrd\nfind .|cpio --quiet -H newc -o|gzip -9 -n \u0026gt; ../initrd\n6、测试内存读写速度\nStream测试内存性能数据\ngcc -O -fopenmp -DSTREAM_ARRAY_SIZE=100000000 -DNTIME=20 stream.c -o stream\nhttps://www.cnblogs.com/iouwenbo/p/14377478.html\n7、查看128个CPU内存占用情况\n1 2 3 4 yum install sysstat -y service sysstat restart # 查看全部CPU每个CPU的占用情况，方便观察不同numa上CPU占用分布 sar -P ALL -u 1 100 8、查看vsock是否通\nyum install nmap\n服务端开启：nc -v --vsock -l 1234\n客户端连接：nc -v --vsock 3 1234\n9、查看根目录大文件超过1G\n1 2 3 4 5 find / -xdev -size +1G -exec ls -l {} \\; find / -type f -size +1G -exec du -h {} \\; # 选其一即可 # 命令作用是：查询根目录（/）下超过1G大小的文件 10、调试coredump文件\n1 2 gdb binary_file core_file bt 11、内核模块编译\n1 2 3 4 5 6 7 8 9 10 #编译kernel配置文件 cd /usr/src/kernels/4.18.0-147.5.2.19.centos.x86_64/ make oldconfig \u0026amp;\u0026amp; make prepare # 修改内核代码后，编译vsock ko模块 make M=/mnt/xxx/tmp/usr/src/linux-5.10.0-60.18.0.50.x86_64/net/vmw_vsock/ -C /lib/modules/`uname -r`/build -j10 # 卸载原有ko，安装新的ko rmmod vhost_vsock rmmod vmw_vsock_virtio_transport_common insmod /mnt/xxx/tmp/usr/src/linux-5.10.0-60.18.0.50.x86_64/net/vmw_vsock//vmw_vsock_virtio_transport_common.ko insmod /lib/modules/`uname -r`/kernel/drivers/vhost/vhost_vsock.ko.xz 12、设置git https校验位false\ngit config --global http.sslVerify false\n13、git命令补全\n拷贝下面文件内容放到文件~/.git-completion.bash里面\nhttps://github.com/git/git/blob/master/contrib/completion/git-completion.bash\nvim ~/.bash_profile\n1 2 3 4 5 if [ -f ~/.git-completion.bash ]; then . ~/.git-completion.bash fi source ~/.bash_profile 14、git保存密码\ngit config --global credential.helper store\n","pubDate":"2024-05-08","title":"常用命令"},{"link":"https://caojunsheng.github.io/posts/virtual/qemu-qom/","plain":"QEMU提供了一套面向对象编程的模型——QOM，即QEMU Object Model，几乎所有的设备如CPU、内存、总线等都是利用这一面向对象的模型来实现的。\nQOM模型的实现代码位于qom/文件夹下的文件中，这涉及了几个结构TypeImpl, ObjectClass, Object和TypeInfo。它们的定义都在include/qom/object.h可以找到，只有TypeImpl的具体结构是在qom/object.c中。\n下面代码流程都是根据qemu-4.1.0代码写的，与最新的qemu代码结构差不多，部分可能存在差异。\n1、各模块初始化函数注册，TypeInfo转为TypeImpl attribute属性constructor即构造函数属性，该属性的设置使得该函数在main函数之前被执行，所以qemu中会先执行调用module_init的方法，调用module_init的一些方法block_init、opts_init、type_init、trace_init、xen_backend_init、libqos_init会先于main函数执行。\n__attrivbute__((constructor))用法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #define module_init(function, type) \\ // __attrivbute__((constructor))属性的函数为构造函数，先于main函数执行 static void __attribute__((constructor)) do_qemu_init_ ## function(void) \\ { \\ register_module_init(function, type); \\ } typedef enum { MODULE_INIT_BLOCK, MODULE_INIT_OPTS, MODULE_INIT_QOM, MODULE_INIT_TRACE, MODULE_INIT_XEN_BACKEND, MODULE_INIT_LIBQOS, MODULE_INIT_MAX } module_init_type; static ModuleTypeList init_type_list[MODULE_INIT_MAX]; static ModuleTypeList *find_type(module_init_type type) { init_lists(); return \u0026amp;init_type_list[type]; } // 注册各模块到init_type_list中，每个模块有个链表 void register_module_init(void (*fn)(void), module_init_type type) { ModuleEntry *e; ModuleTypeList *l; e = g_malloc0(sizeof(*e)); e-\u0026gt;init = fn; e-\u0026gt;type = type; e-\u0026gt;initialized = false; l = find_type(type); // 根据类型找到ModuleTypeList列表 QTAILQ_INSERT_TAIL(l, e, node); // 将注册的各初始化方法放入列表末尾 } 1 2 3 4 5 6 7 8 // 每个模块封装成不同的方法 #define block_init(function) module_init(function, MODULE_INIT_BLOCK) #define opts_init(function) module_init(function, MODULE_INIT_OPTS) #define type_init(function) module_init(function, MODULE_INIT_QOM) #define trace_init(function) module_init(function, MODULE_INIT_TRACE) #define xen_backend_init(function) module_init(function, \\ MODULE_INIT_XEN_BACKEND) #define libqos_init(function) module_init(function, MODULE_INIT_LIBQOS) 以x86 cpu的注册函数为例，target/i386/cpu.c代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 static const TypeInfo x86_cpu_type_info = { .name = TYPE_X86_CPU, // 最终qom/object.c中type_table这个HashTable的key值 .parent = TYPE_CPU, // TYPE_X86_CPU的父对象为TYPE_CPU .instance_size = sizeof(X86CPU), .instance_init = x86_cpu_initfn, .abstract = true, .class_size = sizeof(X86CPUClass), .class_init = x86_cpu_common_class_init, }; static const TypeInfo x86_base_cpu_type_info = { .name = X86_CPU_TYPE_NAME(\u0026#34;base\u0026#34;), // 最终qom/object.c中type_table这个HashTable的key值 .parent = TYPE_X86_CPU, .class_init = x86_cpu_base_class_init, }; static void x86_cpu_register_types(void) { int i; type_register_static(\u0026amp;x86_cpu_type_info); for (i = 0; i \u0026lt; ARRAY_SIZE(builtin_x86_defs); i++) { x86_register_cpudef_types(\u0026amp;builtin_x86_defs[i]); } type_register_static(\u0026amp;max_x86_cpu_type_info); type_register_static(\u0026amp;x86_base_cpu_type_info); #if defined(CONFIG_KVM) || defined(CONFIG_HVF) type_register_static(\u0026amp;microvm_x86_cpu_type_info); type_register_static(\u0026amp;host_x86_cpu_type_info); #endif } // 这里调用type_init，就会相当于构造函数，先于main函数注册 type_init(x86_cpu_register_types) 将TypeInfo转换为TypeImpl，插入到HashTable type_table里 qom/object.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 // 获取type_table，如果未初始化，调用g_hash_table_new初始化一个新的type_table static GHashTable *type_table_get(void) { static GHashTable *type_table; // static函数和变量，type_table相当于全局变量，仅初始化一次 if (type_table == NULL) { type_table = g_hash_table_new(g_str_hash, g_str_equal); } return type_table; } // 最后插入HashTable，key为TypeImpl-\u0026gt;name,value为TypeImpl static void type_table_add(TypeImpl *ti) { assert(!enumerating_types); g_hash_table_insert(type_table_get(), (void *)ti-\u0026gt;name, ti); } // TypeInfo转换为TypeImpl static TypeImpl *type_new(const TypeInfo *info) { TypeImpl *ti = g_malloc0(sizeof(*ti)); int i; g_assert(info-\u0026gt;name != NULL); if (type_table_lookup(info-\u0026gt;name) != NULL) { fprintf(stderr, \u0026#34;Registering `%s\u0026#39; which already exists\\n\u0026#34;, info-\u0026gt;name); abort(); } ti-\u0026gt;name = g_strdup(info-\u0026gt;name); ti-\u0026gt;parent = g_strdup(info-\u0026gt;parent); ti-\u0026gt;class_size = info-\u0026gt;class_size; ti-\u0026gt;instance_size = info-\u0026gt;instance_size; ti-\u0026gt;class_init = info-\u0026gt;class_init; ti-\u0026gt;class_base_init = info-\u0026gt;class_base_init; ti-\u0026gt;class_data = info-\u0026gt;class_data; ti-\u0026gt;instance_init = info-\u0026gt;instance_init; ti-\u0026gt;instance_post_init = info-\u0026gt;instance_post_init; ti-\u0026gt;instance_finalize = info-\u0026gt;instance_finalize; ti-\u0026gt;abstract = info-\u0026gt;abstract; for (i = 0; info-\u0026gt;interfaces \u0026amp;\u0026amp; info-\u0026gt;interfaces[i].type; i++) { ti-\u0026gt;interfaces[i].typename = g_strdup(info-\u0026gt;interfaces[i].type); } ti-\u0026gt;num_interfaces = i; return ti; } static TypeImpl *type_register_internal(const TypeInfo *info) { TypeImpl *ti; ti = type_new(info); type_table_add(ti); return ti; } TypeImpl *type_register(const TypeInfo *info) { assert(info-\u0026gt;parent); return type_register_internal(info); } TypeImpl *type_register_static(const TypeInfo *info) { return type_register(info); } 2、各模块初始化 vl.c的main函数中调用各模块初始化\n1 2 3 4 5 6 7 8 int main(int argc, char **argv, char **envp) { …… module_call_init(MODULE_INIT_TRACE); module_call_init(MODULE_INIT_QOM); module_call_init(MODULE_INIT_OPTS); …… } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void module_call_init(module_init_type type) { ModuleTypeList *l; ModuleEntry *e; l = find_type(type); QTAILQ_FOREACH(e, l, node) { if (!e-\u0026gt;initialized) { e-\u0026gt;init(); // 此处对比上面例子，相当于调用x86_cpu_register_types函数，注册TYPE_X86_CPU类型的初始化函数 e-\u0026gt;initialized = true; // 设置标志位initialized，不会重复初始化 } } } 3、ObjectClass初始化 以 select_machine为例看下QOM初始化流程 main-\u0026gt;select_machine-\u0026gt;object_class_get_list-\u0026gt;object_class_foreach-\u0026gt;type_table_get;object_class_foreach_tramp-\u0026gt;type_initialize-\u0026gt;class_base_init;class_init\nvl.c中main函数调用select_machine\n1 2 3 4 5 6 7 8 machine_class = select_machine(); static MachineClass *select_machine(void) { GSList *machines = object_class_get_list(TYPE_MACHINE, false); MachineClass *machine_class = find_default_machine(machines); …… } qom/object.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 static void object_class_get_list_tramp(ObjectClass *klass, void *opaque) { GSList **list = opaque; // g_slist_prepend(*list, klass);是将klass插入到*list的开头的地方 *list = g_slist_prepend(*list, klass); } // 根据传入的类型TYPE_MACHINE获取对应的ObjectClass GSList *object_class_get_list(const char *implements_type, bool include_abstract) { GSList *list = NULL; object_class_foreach(object_class_get_list_tramp, implements_type, include_abstract, \u0026amp;list); return list; } void object_class_foreach(void (*fn)(ObjectClass *klass, void *opaque), const char *implements_type, bool include_abstract, void *opaque) { OCFData data = { fn, implements_type, include_abstract, opaque }; enumerating_types = true; // 从HashTable type_table中根据type类型拿到TypeImpl g_hash_table_foreach(type_table_get(), object_class_foreach_tramp, \u0026amp;data); enumerating_types = false; } static void object_class_foreach_tramp(gpointer key, gpointer value, gpointer opaque) { OCFData *data = opaque; TypeImpl *type = value; ObjectClass *k; // 此处调用machine类型的初始化函数 type_initialize(type); k = type-\u0026gt;class; if (!data-\u0026gt;include_abstract \u0026amp;\u0026amp; type-\u0026gt;abstract) { return; } if (data-\u0026gt;implements_type \u0026amp;\u0026amp; !object_class_dynamic_cast(k, data-\u0026gt;implements_type)) { return; } // 最后调用data-\u0026gt;fn，实际就是调用object_class_get_list_tramp函数 data-\u0026gt;fn(k, data-\u0026gt;opaque); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 static void type_initialize(TypeImpl *ti) { TypeImpl *parent; // 如果class已被初始化过，则不需要再初始化了 if (ti-\u0026gt;class) { return; } ti-\u0026gt;class_size = type_class_get_size(ti); ti-\u0026gt;instance_size = type_object_get_size(ti); /* Any type with zero instance_size is implicitly abstract. * This means interface types are all abstract. */ if (ti-\u0026gt;instance_size == 0) { ti-\u0026gt;abstract = true; } // 中间省略…… ti-\u0026gt;class-\u0026gt;type = ti; // 如果有父对象，则先初始化父对象，递归调用初始化全部对象 while (parent) { if (parent-\u0026gt;class_base_init) { parent-\u0026gt;class_base_init(ti-\u0026gt;class, ti-\u0026gt;class_data); } parent = type_get_parent(parent); } // 此处初始化这个ObjectClass if (ti-\u0026gt;class_init) { ti-\u0026gt;class_init(ti-\u0026gt;class, ti-\u0026gt;class_data); } } 上面实际调用的则是TypeImpl中的class_init，这在最开始先于main函数执行的注册，实际调用的是machine_class_init hw/core/machine.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static const TypeInfo machine_info = { .name = TYPE_MACHINE, .parent = TYPE_OBJECT, .abstract = true, .class_size = sizeof(MachineClass), .class_init = machine_class_init, .class_base_init = machine_class_base_init, .instance_size = sizeof(MachineState), .instance_init = machine_initfn, .instance_finalize = machine_finalize, }; static void machine_register_types(void) { type_register_static(\u0026amp;machine_info); } type_init(machine_register_types) 总结一下就是： 1、__attribute__((constructor))的修饰函数会先于main函数执行，type_init的参数是XXX_register_types函数指针，将函数指针传递到ModuleEntry的init函数指针，最后就是将这个ModuleEntry插入到ModuleTypeList 2、main函数中的module_call_init(MODULE_INIT_QOM);调用了MODULE_INIT_QOM类型的ModuleTypeList中的所有ModuleEntry中的init()函数，也就是第一步type_init的第一个参数XXX_register_types函数指针 3、然后就是XXX_register_types函数的初始化操作了，就是创建TypeImpl的哈希表 4、ObjectClass获取的时候，会根据Type类型拿到对应的TypeImpl对象，如果class已经被初始化过，就无需初始化，未被初始化，则还是会调用TypeInfo定义的class_init函数初始化对象。\n推荐书籍：QEMUKVM源码解析与应用带书签.pdf 第二章QEMU基本纽件\nWritten with StackEdit.\n","pubDate":"2024-05-08","title":"qemu QOM代码"},{"link":"https://caojunsheng.github.io/posts/linux/pcie-aer/","plain":"1、AER简介 AER 即 Advanced Error Reporting高级错误报告，是PCIe高级特性，用于报告PCIe 错误信息。\n分为\n可纠正错误（Correctable errors）是指错误发生后，硬件可以自动恢复。 不可纠正错误（Uncorrectable errors）错误发生后，影响设备功能，硬件不能自动恢复。 不可纠正错误分为\nERR_FATAL是致命错误，此错误类型影响了PCIe link链路。 ERR_NONFATAL是指影响了设备功能，但是PCIe link还是稳定的。 2、lspci查看PCIe设备AER能力 使用下面命令可以查看PCIe设备的详细信息和相关的Capabilities\n1 # lspci -vvs 89:00.7 其中AER相关能力在这里\n1 2 3 4 5 6 7 8 9 Capabilities: [100 v2] Advanced Error Reporting UESta:\tDLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq+ ACSViol- UEMsk:\tDLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq+ ACSViol- UESvrt:\tDLP+ SDES+ TLP+ FCP+ CmpltTO- CmpltAbrt- UnxCmplt- RxOF+ MalfTLP+ ECRC- UnsupReq- ACSViol- CESta:\tRxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr+ CEMsk:\tRxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr- AERCap:\tFirst Error Pointer: 00, ECRCGenCap+ ECRCGenEn- ECRCChkCap+ ECRCChkEn- MultHdrRecCap- MultHdrRecEn- TLPPfxPres- HdrLogCap+ HeaderLog: 00000000 00000000 00000000 00000000 寄存器命名\nUESta: Uncorrectable Error Status，表示不可纠正错误状态，用于指示发生不可纠正错误的状态。 UEMsk: Uncorrectable Error Mask，表示不可纠正错误掩码，用于掩盖或屏蔽不可纠正错误。 UESvrt: Uncorrectable Error Severity，表示不可纠正错误严重性，用于指示不可纠正错误的严重程度。 CESta: Correctable Error Status，表示可纠正错误状态，用于指示发生可纠正错误的状态。 CEMsk: Correctable Error Mask，表示可纠正错误掩码，用于掩盖或屏蔽可纠正错误。 Uncorrectable Error\nDLP: Data Link Protocol Error，数据链路协议错误，表示数据链路协议错误。 SDES: Surprise Down Error Status，意外下降错误状态，表示设备在意外下降时的错误状态。 TLP: Transaction Layer Packet，事务层包，表示事务层包错误。 FCP: Flow Control Protocol Error，流控制协议错误，表示流控制协议错误。 CmpltTO: Completion Timeout，完成超时，表示完成操作超时。 CmpltAbrt: Completion Abort，完成中止，表示完成操作中止。 UnxCmplt: Unsupported Completion，不支持的完成，表示不支持的完成操作。 RxOF: Receiver Overflow，接收器溢出，表示接收器溢出错误。 MalfTLP: Malformed TLP，格式错误的TLP，表示格式错误的事务层包。 ECRC: ECRC Error，ECRC 错误，表示ECRC校验错误。 UnsupReq: Unsupported Request，不支持的请求，表示设备不支持的请求。 ACSViol: ACS Violation，ACS 违规，表示ACS规则违反。 Correctable Error\nRxErr: Receive Error，表示接收数据时发生错误。 BadTLP: Bad TLP，表示传输层包（TLP）格式错误或无效。 BadDLLP: Bad DLLP，表示数据链路层包（DLLP）格式错误或无效。 Rollover: 溢出，表示发生了溢出错误。 Timeout: 超时，表示操作超时。 AdvNonFatalErr: 高级非致命错误，表示发生了高级非致命错误。 AERCap\nECRCGenCap 和 ECRCGenEn 表示设备是否支持和启用 ECRC 生成（ECRC generation）功能。 ECRCChkCap 和 ECRCChkEn 表示设备是否支持和启用 ECRC 检查（ECRC checking）功能。 MultHdrRecCap 和 MultHdrRecEn 表示设备是否支持和启用多头记录（Multiple Header Record）功能。 TLPPfxPres 表示设备是否支持 TLP 前缀保留（TLP Prefix Preservation）功能。 HdrLogCap 表示设备是否支持头部日志（Header Logging）功能。 3、setpci查看设备AER寄存器值 查看设备89:00.7的AER Uncorrectable Error Severity寄存器值的命令如下所示：\n1 2 # setpci -s 89:00.7 100+0C.L 00463030 -s 用于指定设备的bdf号，格式如：[[[\u0026lt;domain\u0026gt;]:][\u0026lt;bus\u0026gt;]:][\u0026lt;slot\u0026gt;][.[\u0026lt;func\u0026gt;]] 89:00.7 代表具体的设备 100 是参考lspci查出来的起始位Capabilities: [100 v2] Advanced Error Reporting +0C 代表AER Uncorrectable Error Severity Register值的偏移量，这个值是根据PCIe Spec里面查到的 L代表是Long，长字，即32位，也可以是B、W等\nB：表示 Byte，即字节。在寄存器中，每个字节通常由 8 位组成。 W：表示 Word，即字。在寄存器中，一个字通常由 16 位或 2 个字节组成。 L：表示 Long，即长字。在寄存器中，一个长字通常由 32 位或 4 个字节组成。 而查询出来的值00463030则对应到32位寄存器值，每个bit对应一个错误的严重程度，对应到lspci上查询出来的，+代表该bit位为1，-代表该bit位为0。 UESvrt:\tDLP+ SDES+ TLP+ FCP+ CmpltTO- CmpltAbrt- UnxCmplt- RxOF+ MalfTLP+ ECRC- UnsupReq- ACSViol-\n00463030换算成2进制为0100 0110 0011 0000 0011 0000\n其中Bit4、Bit5、Bit12、Bit13、Bit17、Bit18、Bit22位为1，对应到PCIe Spec上，即\nBit4：Data Link Protocol Error Severity（DLP） Bit5：Surprise Down Error Severity（SDES） Bit12：Poisoned TLP Received Severity（TLP） Bit13：Flow Control Protocol Error Severity（FCP） Bit17：Receiver Overflow Severity（RxOF） Bit18：Malformed TLP Severity（MalfTLP） Bit22：Uncorrectable Internal Error Severity 正好与lspci查询出来的结果一致。 4、setpci设置设备AER寄存器值 同样以设备89:00.7的AER Uncorrectable Error Severity寄存器值为例， 上面查询到的UESvrt的CmpltTO为-，我们想把它设置为+，参考PCIe Spec，我们只要设置对应寄存器的Bit14为1即可，命令如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # setpci -s 89:00.7 100+0C.L 00463030 # setpci -s 89:00.7 100+0C.L=00467030 # setpci -s 89:00.7 100+0C.L 00467030 # lspci -vvs 89:00.7 Capabilities: [100 v2] Advanced Error Reporting UESta:\tDLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq+ ACSViol- UEMsk:\tDLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq+ ACSViol- UESvrt:\tDLP+ SDES+ TLP+ FCP+ CmpltTO+ CmpltAbrt- UnxCmplt- RxOF+ MalfTLP+ ECRC- UnsupReq- ACSViol- CESta:\tRxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr+ CEMsk:\tRxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr- AERCap:\tFirst Error Pointer: 00, ECRCGenCap+ ECRCGenEn- ECRCChkCap+ ECRCChkEn- MultHdrRecCap- MultHdrRecEn- TLPPfxPres- HdrLogCap+ HeaderLog: 00000000 00000000 00000000 00000000 上述查询出来的UESvrt的CmpltTO确实是+，设置成功。\nhttps://blog.csdn.net/zsmcdut/article/details/120151896\n","pubDate":"2024-05-08","title":"PCIe AER寄存器值查看和修改"},{"link":"https://caojunsheng.github.io/posts/golang/07_goinline/","plain":"一、什么是函数内联 内联优化是什么？ 内联(inlining)是编程语言编译器常用的优化手段，其优化的对象为函数，也称为函数内联。如果某函数F支持内联，则意味着编译器可以用F的函数体/函数定义替换掉对函数F进行调用的代码，以消除函数调用带来的额外开销，这个过程如下图所示： 但是内联并不是只有优点而无缺点，因为内联，其实就是将一个函数调用原地展开，替换成这个函数的实现。当该函数被多次调用，就会被多次展开，这会增加编译后二进制文件的大小。而非内联函数，只需要保存一份函数体的代码，然后进行调用。所以，在空间上，一般来说使用内联函数会导致生成的可执行文件变大。\n如何判断函数是否支持内联 我们先看下面的一段代码，testInline1、testInline2、testInline3是否能够被内联，我们猜想的是testInline1能够被内联，testInline2和testInline3不能够被内联。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(testInline1(1, 2)) fmt.Println(testInline2(1, 2)) fmt.Println(testInline3(1, 2)) } func testInline1(a, b int) int { if a \u0026gt; b { return a } return b } //go:noinline func testInline2(a, b int) int { if a \u0026gt; b { return a } return b } func testInline3(a, b int) int { for i := 0; i \u0026lt; 10; i++ { fmt.Println(i) } if a \u0026gt; b { return a } return b } 方法1：使用go tool compile 我们可以使用go tool compile查看函数是否能够被内联：\n1 go tool compile -m=2 test.go testInline1符合我们预期，是不能被内联的 testInline2由于被打上注释“//go:noinline”，所以也不会被内联 testInline3则是因为函数过于复杂，超过阈值80了，所以也不能被内联 1 2 3 4 5 6 7 8 9 10 $ go tool compile -m=2 test.go test.go:15:6: can inline testInline1 with cost 8 as: func(int, int) int { if a \u0026gt; b { return a }; return b } test.go:23:6: cannot inline testInline2: marked go:noinline test.go:30:6: cannot inline testInline3: function too complex: cost 96 exceeds budget 80 test.go:32:14: inlining call to fmt.Println func(...interface {}) (int, error) { var fmt..autotmp_3 int; fmt..autotmp_3 = \u0026lt;nil\u0026gt;; var fmt..autotmp_4 error; fmt..autotmp_4 = \u0026lt;nil\u0026gt;; fmt..autotmp_3, fmt..autotmp_4 = fmt.Fprintln(io.Writer(os.Stdout), fmt.a...); return fmt..autotmp_3, fmt..autotmp_4 } test.go:9:6: cannot inline main: function too complex: cost 359 exceeds budget 80 test.go:10:25: inlining call to testInline1 func(int, int) int { if a \u0026gt; b { return a }; return b } test.go:10:13: inlining call to fmt.Println func(...interface {}) (int, error) { var fmt..autotmp_3 int; fmt..autotmp_3 = \u0026lt;nil\u0026gt;; var fmt..autotmp_4 error; fmt..autotmp_4 = \u0026lt;nil\u0026gt;; fmt..autotmp_3, fmt..autotmp_4 = fmt.Fprintln(io.Writer(os.Stdout), fmt.a...); return fmt..autotmp_3, fmt..autotmp_4 } test.go:11:13: inlining call to fmt.Println func(...interface {}) (int, error) { var fmt..autotmp_3 int; fmt..autotmp_3 = \u0026lt;nil\u0026gt;; var fmt..autotmp_4 error; fmt..autotmp_4 = \u0026lt;nil\u0026gt;; fmt..autotmp_3, fmt..autotmp_4 = fmt.Fprintln(io.Writer(os.Stdout), fmt.a...); return fmt..autotmp_3, fmt..autotmp_4 } test.go:12:13: inlining call to fmt.Println func(...interface {}) (int, error) { var fmt..autotmp_3 int; fmt..autotmp_3 = \u0026lt;nil\u0026gt;; var fmt..autotmp_4 error; fmt..autotmp_4 = \u0026lt;nil\u0026gt;; fmt..autotmp_3, fmt..autotmp_4 = fmt.Fprintln(io.Writer(os.Stdout), fmt.a...); return fmt..autotmp_3, fmt..autotmp_4 } 方法2：使用go build 由于go tool compile仅支持单个文件,使用go build编译一个目录查询函数是否被内联 执行如下命令：\n1 2 3 4 5 6 7 8 9 10 $ go build -gcflags=\u0026#34;-m=2\u0026#34; . .\\test.go:15:6: can inline testInline1 with cost 8 as: func(int, int) int { if a \u0026gt; b { return a }; return b } .\\test.go:23:6: cannot inline testInline2: marked go:noinline .\\test.go:30:6: cannot inline testInline3: function too complex: cost 96 exceeds budget 80 .\\test.go:32:14: inlining call to fmt.Println func(...interface {}) (int, error) { var fmt..autotmp_3 int; fmt..autotmp_3 = \u0026lt;nil\u0026gt;; var fmt..autotmp_4 error; fmt..autotmp_4 = \u0026lt;nil\u0026gt;; fmt..autotmp_3, fmt..autotmp_4 = fmt.Fprintln(io.Writer(os.Stdout), fmt.a...); return fmt..autotmp_3, fmt..autotmp_4 } .\\test.go:9:6: cannot inline main: function too complex: cost 359 exceeds budget 80 .\\test.go:10:25: inlining call to testInline1 func(int, int) int { if a \u0026gt; b { return a }; return b } .\\test.go:10:13: inlining call to fmt.Println func(...interface {}) (int, error) { var fmt..autotmp_3 int; fmt..autotmp_3 = \u0026lt;nil\u0026gt;; var fmt..autotmp_4 error; fmt..autotmp_4 = \u0026lt;nil\u0026gt;; fmt..autotmp_3, fmt..autotmp_4 = fmt.Fprintln(io.Writer(os.Stdout), fmt.a...); return fmt..autotmp_3, fmt..autotmp_4 } .\\test.go:11:13: inlining call to fmt.Println func(...interface {}) (int, error) { var fmt..autotmp_3 int; fmt..autotmp_3 = \u0026lt;nil\u0026gt;; var fmt..autotmp_4 error; fmt..autotmp_4 = \u0026lt;nil\u0026gt;; fmt..autotmp_3, fmt..autotmp_4 = fmt.Fprintln(io.Writer(os.Stdout), fmt.a...); return fmt..autotmp_3, fmt..autotmp_4 } .\\test.go:12:13: inlining call to fmt.Println func(...interface {}) (int, error) { var fmt..autotmp_3 int; fmt..autotmp_3 = \u0026lt;nil\u0026gt;; var fmt..autotmp_4 error; fmt..autotmp_4 = \u0026lt;nil\u0026gt;; fmt..autotmp_3, fmt..autotmp_4 = fmt.Fprintln(io.Writer(os.Stdout), fmt.a...); return fmt..autotmp_3, fmt..autotmp_4 } Written with StackEdit.\n","pubDate":"2023-01-14","title":"golang内联判断"},{"link":"https://caojunsheng.github.io/posts/golang/06_interview/","plain":"Go面试题及详解 1. 下面这段代码的输出什么? 1 2 3 4 5 6 func Test1(t *testing.T) { defer func() { fmt.Println(\u0026#34;打印前\u0026#34;) }() defer func() { fmt.Println(\u0026#34;打印中\u0026#34;) }() defer func() { fmt.Println(\u0026#34;打印后\u0026#34;) }() panic(\u0026#34;触发异常\u0026#34;) } 输出 打印后\n打印中\n打印前\npanic: 触发异常\n解析 defer 的执行顺序是先进后出,发生panic后，会先执行defer\n2. 下段代码输出什么? 1 2 3 4 5 6 7 8 9 10 11 12 func Test2(t *testing.T) { slice := []int{0, 1, 2, 3} m := make(map[int]*int) for key, val := range slice { m[key] = \u0026amp;val } for k, v := range m { fmt.Printf(\u0026#34;key: %d, value: %d \\n\u0026#34;, k, *v) } } 输出 key: 0, value: 3\nkey: 1, value: 3\nkey: 2, value: 3\nkey: 3, value: 3\n解析: for range 循环的时候会创建每个元素的副本，而不是元素的引用， 所以 m[key] = \u0026amp;val 取的都是变量 val 的地址，所以最后 map 中的所有元素的值都是变量 val 的地址， 因为最后 val 被赋值为3，所有输出都是3.\n3. 下面代码输出什么? 1 2 3 4 5 6 7 8 9 func Test3(t *testing.T) { i := make([]int, 5) i = append(i, 1, 2, 3) fmt.Println(i) j := make([]int, 0) j = append(j, 1, 2, 3, 4) fmt.Println(j) } 输出 [0 0 0 0 0 1 2 3]\n[1 2 3 4]\n解析 make如果输入值，会默认给其初始化默认值\n4. 下面这段代码有什么错误吗？ 1 2 3 func funcMui(x,y int)(sum int,error){ return x+y,nil } 解析 第二个返回值没有命名,在函数有多个返回值时，只要有一个返回值有命名， 其他的也必须命名。如果有多个返回值必须加上括号()； 如果只有一个返回值且命名也必须加上括号()。 这里的第一个返回值有命名 sum，第二个没有命名，所以错误。\n5. new() 与 make() 的区别 new只初始化并返回指针，而make不仅仅要做初始化，还需要设置一些数组的长度、容量等\n6. 下面几段代码能否通过编译，如果能，输出什么? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func main() { list := new([]int) // 编译错误 // new([]int) 之后的 list 是一个未设置长度的 *[]int 类型的指针 // 不能对未设置长度的指针执行 append 操作。 list = append(list, 1) fmt.Println(list) s1 := []int{1, 2, 3} s2 := []int{4, 5} // 编译错误，s2需要展开 s1 = append(s1, s2) fmt.Println(s1) } 7. 下面能否通过编译? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func Test7(t *testing.T) { sn1 := struct { age int name string }{age: 11, name: \u0026#34;qq\u0026#34;} sn2 := struct { age int name string }{age: 11, name: \u0026#34;qq\u0026#34;} // true if sn1 == sn2 { fmt.Println(\u0026#34;sn1 == sn2\u0026#34;) } sm1 := struct { age int m map[string]string }{age: 11, m: map[string]string{\u0026#34;a\u0026#34;: \u0026#34;1\u0026#34;}} sm2 := struct { age int m map[string]string }{age: 11, m: map[string]string{\u0026#34;a\u0026#34;: \u0026#34;1\u0026#34;}} // 编译错误，含有map、slice类型的struct不能进行比较 if sm1 == sm2 { fmt.Println(\u0026#34;sm1 == sm2\u0026#34;) } } 8. 通过指针变量 p 访问其成员变量 name，有哪几种方式？ A. p.name\nB. (\u0026amp;p).name\nC. (*p).name\nD. p-\u0026gt;name\n答案 AC\n9. 关于字符串连接，下面语法正确的是？ A. str := \u0026lsquo;abc\u0026rsquo; + \u0026lsquo;123\u0026rsquo;\nB. str := \u0026ldquo;abc\u0026rdquo; + \u0026ldquo;123\u0026rdquo;\nC. str := \u0026lsquo;123\u0026rsquo; + \u0026ldquo;abc\u0026rdquo;\nD. fmt.Sprintf(\u0026ldquo;abc%d\u0026rdquo;, 123)\n答案 BD\ngolang单引号\u0026rsquo;\u0026lsquo;中的内容表示单个字符（rune）,反引号``中的内容表示不可转义的字符串\n10. 关于iota，下面代码输出什么? 1 2 3 4 5 6 7 8 9 10 11 12 func Test10(t *testing.T) { const ( x = iota _ y z = \u0026#34;pi\u0026#34; k p = iota q ) fmt.Println(x, y, z, k, p, q) } 输出 0 2 pi pi 5 6\n11. 下面赋值正确的是? A. var x = nil\nB. var x interface{} = nil\nC. var x string = nil\nD. var x error = nil\n答案 BD\n12. 关于channel，下面语法正确的是? A. var ch chan int\nB. ch := make(chan int)\nC. \u0026lt;- ch\nD. ch \u0026lt;-\n答案 ABC\n写 chan 时，\u0026lt;- 右端必须要有值\n13. 下面代码输出什么？ 1 2 3 4 5 6 7 8 9 func hello(num ...int) { num[0] = 18 } func Test13(t *testing.T) { i := []int{5, 6, 7} hello(i...) fmt.Println(i[0]) } A.18\nB.5\nC.Compilation error\n答案 A\n可变参数是指针传递\n14. 下面选择哪个？ 1 2 3 4 5 func main() { a := 5 b := 8.1 fmt.Println(a + b) } A.13.1\nB.13\nC.compilation error\n答案 C\n整形与浮点形不能相加\n15. 下面代码输出什么？ 1 2 3 4 5 func Test15(t *testing.T) { a := [5]int{1, 2, 3, 4, 5} s := a[3:4:4] fmt.Println(s[0]) } A.3\nB.4\nC.compilation error\n答案 B\na[3:4][0] = 4 切片的长度是1，容量是2\na[4:4][0] 报越界错误\na[3:4:4][0] = 4 切片的长度是1，容量是1，最后一个4表示切片容量的最大坐标(不含)\n16. 下面代码输出什么？ 1 2 3 4 5 6 7 8 9 func Test16(t *testing.T) { a := [2]int{5, 6} b := [3]int{5, 6} if a == b { fmt.Println(\u0026#34;equal\u0026#34;) } else { fmt.Println(\u0026#34;not equal\u0026#34;) } } A. compilation error\nB. equal\nC. not equal\n答案 A 编译错误\n对于数组而言，一个数组是由数组中的值和数组的长度两部分组成的，如果两个数组长度不同，那么两个数组是属于 不同类型的，是不能进行比较的\n17. 下列哪个类型可以使用 cap()函数？ A. array\nB. slice\nC. map\nD. channel\n答案 A B D array 返回数组的元素个数； slice 返回 slice 的最大容量； channel 返回 channel 的容量；\n18. 下面代码输出什么？ 1 2 3 4 5 6 7 8 func Test18(t *testing.T) { var i interface{} if i == nil { fmt.Println(\u0026#34;nil\u0026#34;) return } fmt.Println(\u0026#34;not nil\u0026#34;) } A. nil\nB. not nil\nC. compilation error\n答案 A\n当且仅当接口的动态值和动态类型都为 nil 时，接口类型值才为 nil。\n19. 下面代码输出什么？ 1 2 3 4 5 func Test19(t *testing.T) { s := make(map[string]int) delete(s, \u0026#34;h\u0026#34;) fmt.Println(s[\u0026#34;h\u0026#34;]) } A. runtime panic\nB. 0\nC. compilation error\n答案 B\n删除 map 不存在的键值对时，不会报错，相当于没有任何作用； 获取不存在的键值对时，返回值类型对应的零值，所以返回 0\n可以使用if v, ok := s[\u0026ldquo;h\u0026rdquo;]; ok {}的方式判断键值对是否存在\n20. 下面代码输出什么？ 1 2 3 4 5 func Test20(t *testing.T) { i := -5 j := +5 fmt.Printf(\u0026#34;%+d %+d\u0026#34;, i, j) } A. -5 +5\nB. +5 +5\nC. 0 0\n答案 A\n%+d 是带符号输出\n21. 定义一个全局字符串变量，下列正确的是？ A. var str string\nB. str := \u0026quot;\u0026quot;\nC. str = \u0026quot;\u0026quot;\nD. var str = \u0026quot;\u0026quot;\n答案 A D\nB 只支持局部变量声明；C 是赋值，str 必须在这之前已经声明；\n22. 下列代码输出什么？ 1 2 3 4 5 6 7 8 func f(i int) { fmt.Println(i) } func Test22(t *testing.T) { i := 5 defer f(i) i = i + 10 } 输出 5\nf() 函数的参数在执行 defer 语句的时候会保存一份副本， 在实际调用 f() 函数时用，所以是 5.\n23. 下列代码输出什么？ 1 2 3 4 5 func Test23(t *testing.T) { str := \u0026#34;hello\u0026#34; str[0] = \u0026#39;x\u0026#39; fmt.Println(str) } A. hello\nB. xello\nC. compilation error\n答案 C 编译错误\nGo 语言中的字符串是只读的\n24. 下面代码输出什么？ 1 2 3 4 5 6 7 8 9 10 func inc(p *int) int { *p++ return *p } func Test24(t *testing.T) { p := 1 inc(\u0026amp;p) fmt.Println(p) } A. 1\nB. 2\nC. 3\n答案 B\n25. 关于可变参数的函数调用正确的是？ 1 2 3 4 5 6 7 8 func add(args ...int) int { sum := 0 for _, arg := range args { sum += arg } return sum } A. add(1, 2)\nB. add(1, 3, 7)\nC. add([]int{1, 2})\nD. add([]int{1, 3, 7}…)\n答案 A B D\n26. 下列代码中下划线处可填入哪个变量会打印\u0026quot;yes nil\u0026quot;？ 1 2 3 4 5 6 7 8 9 func Test26(t *testing.T) { var s1 []int var s2 = []int{} if ___ == nil { fmt.Println(\u0026#34;yes nil\u0026#34;) } else { fmt.Println(\u0026#34;no nil\u0026#34;) } } A. s1\nB. s2\nC. s1、s2 都可以\n答案 A\nnil 切片和空切片。nil 切片和 nil 相等，一般用来表示一个不存在的切片； 空切片和 nil 不相等，表示一个空的集合\n27. 下面代码输出什么？ 1 2 3 4 func Test27(t *testing.T) { i := 65 fmt.Println(string(i)) } A. A\nB. 65\nC. compilation error\n答案 A\nUTF-8 编码中，十进制数字 65 对应的符号是 A\n28. 切片a,b,c的容量分别是多少？ 1 2 3 4 5 6 7 8 9 func Test28(t *testing.T) { s := [3]int{1, 2, 3} a := s[:0] b := s[:2] c := s[1:2:cap(s)] fmt.Println(cap(a)) fmt.Println(cap(b)) fmt.Println(cap(c)) } 输出 3 3 2\n操作符 [i:j:k]，k 主要是用来限制切片的容量， 但是不能大于数组的长度 ，截取得到的切片长度和容量计算方法是 j-i、k-i\n29. 下面代码输出什么？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func increaseA() int { var i int defer func() { i++ }() return i } func increaseB() (r int) { defer func() { r++ }() return r } func Test29(t *testing.T) { fmt.Println(increaseA()) fmt.Println(increaseB()) } 输出 0 1\n30. 函数 f1(),f2(),f3()分别返回什么？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func f1() (r int) { defer func() { r++ }() return 0 } func f2() (r int) { t := 5 defer func() { t = t + 5 }() return t } func f3() (r int) { defer func(r int) { r = r + 5 }(r) return 1 } func Test30(t *testing.T) { fmt.Println(f1()) fmt.Println(f2()) fmt.Println(f3()) } 输出 1 5 1\n31. 下面代码输出什么？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Person struct { age int } func Test31(t *testing.T) { person := \u0026amp;Person{28} // 1 defer fmt.Println(person.age) // 2 defer func(p *Person) { fmt.Println(p.age) }(person) // 3 defer func() { fmt.Println(person.age) }() person.age = 29 } 输出 29 29 28\n1.person.age 此时是将 28 当做 defer 函数的参数，会把 28 缓存在栈中，等到最后执行该 defer 语句的时候取出，即输出 28；\n2.defer 缓存的是结构体 Person{28} 的地址，最终 Person{28} 的 age 被重新赋值为 29，所以 defer 语句最后执行的时候，依靠缓存的地址取出的 age 便是 29，即输出 29；\n3.闭包引用，输出 29；\n32. 下面的两个切片声明中有什么区别？哪个更可取？ A. var a []int\nB. a := []int{}\n答案 A\nA 声明的是 nil 切片；B 声明的是长度和容量都为 0 的空切片。 A的声明不会分配内存，优先选择\n33. A,B，C，D那个有语法错误？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type S struct { } func m(x interface{}) { } func g(x *interface{}) { } func Test33(t *testing.T) { s := S{} p := \u0026amp;s m(s) //A g(s) //B m(p) //C g(p) //D } 答案 B D 会编译错误\n函数参数为 interface{} 时可以接收任何类型的参数，包括用户自定义类型等， 即使是接收指针类型也用 interface{}，而不是使用 *interface{}。 永远不要使用一个指针指向一个接口类型，因为它已经是一个指针。\n34. 下面代码输出什么？ 1 2 3 4 5 6 7 8 func Test34(t *testing.T) { s1 := []int{1, 2, 3} s2 := s1[1:] s2[1] = 4 fmt.Println(s1) s2 = append(s2, 5, 6, 7) fmt.Println(s1) } 答案 [1 2 4]\n[1 2 4]\ngolang 中切片底层的数据结构是数组。当使用 s1[1:] 获得切片 s2，和 s1 共享同一个底层数组 这会导致 s2[1] = 4 语句影响 s1。 而 append 操作会导致底层数组扩容，生成新的数组，因此追加数据后的 s2 不会影响 s1\n35. 下列代码输出什么？ 1 2 3 4 5 6 7 func Test35(t *testing.T) { if a := 1; false { } else if b := 2; false { } else { println(a, b) } } 答案 1 2\n36. 下列代码输出什么？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func Test36(t *testing.T) { a := 1 b := 2 defer calc(\u0026#34;A\u0026#34;, a, calc(\u0026#34;10\u0026#34;, a, b)) a = 0 defer calc(\u0026#34;B\u0026#34;, a, calc(\u0026#34;20\u0026#34;, a, b)) b = 1 } func calc(index string, a, b int) int { ret := a + b fmt.Println(index, a, b, ret) return ret } 答案 10 1 2 3\n20 0 2 2\nB 0 2 2\nA 1 3 4\n37. 下列代码输出什么？ 1 2 3 4 5 6 func Test37(t *testing.T) { m := map[int]string{0: \u0026#34;zero\u0026#34;, 1: \u0026#34;one\u0026#34;} for k, v := range m { fmt.Println(k, v) } } 答案 0 zero\n1 one\n或者\n1 one\n0 zero\nmap输出是无序的\n38. 下面代码是否可以编译通过？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type People interface { Speak(string) string } type Student struct{} func (stu *Student) Speak(think string) { fmt.Println(think) } func main() { var peo People = Student{} think := \u0026#34;speak\u0026#34; fmt.Println(peo.Speak(think)) } 答案 不能编译通过，因为是 *Student 实现了Speak，并不是 值类型的Student， 但是如果是 Student 类型实现了Speak方法，那么用 值类型的Student{} 或是指针类型的\u0026amp;Student{}都可以访问到该方法\n39. 下面代码输出什么？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const ( a = iota b = iota ) const ( name = \u0026#34;name\u0026#34; c = iota d = iota ) func Test39(t *testing.T) { fmt.Println(a) fmt.Println(b) fmt.Println(c) fmt.Println(d) } 答案 0 1 1 2\niota 在 const 关键字出现时将被重置为0，const中每新增一行常量声明将使 iota 计数一次。\n39. 下面代码输出什么？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 type People interface { Show() } type Student struct{} func (stu *Student) Show() { } func Test40(t *testing.T) { var s *Student if s == nil { fmt.Println(\u0026#34;s is nil\u0026#34;) } else { fmt.Println(\u0026#34;s is not nil\u0026#34;) } var p People = s if p == nil { fmt.Println(\u0026#34;p is nil\u0026#34;) } else { fmt.Println(\u0026#34;p is not nil\u0026#34;) } } 答案 s is nil\np is not nil\n当且仅当动态值和动态类型都为 nil 时，接口类型值才为 nil。上面的代码，给变量 p 赋值之后， p 的动态值是 nil，但是动态类型却是 *Student，是一个 nil 指针，所以相等条件不成立。\n41. 下列代码输出什么？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type Direction int const ( North Direction = iota East South West ) func (d Direction) String() string { return [...]string{\u0026#34;North\u0026#34;, \u0026#34;East\u0026#34;, \u0026#34;South\u0026#34;, \u0026#34;West\u0026#34;}[d] } func Test41(t *testing.T) { fmt.Println(South) } 答案 South\n42. 下列代码是否可以编译通过？ 1 2 3 4 5 6 7 8 9 10 11 12 type Square struct { x, y int } var m = map[string]Square{ \u0026#34;foo\u0026#34;: Square{2, 3}, } func Test42(t *testing.T) { m[\u0026#34;foo\u0026#34;].x = 1 fmt.Println(m[\u0026#34;foo\u0026#34;].x) } 答案 编译失败， m[\u0026ldquo;foo\u0026rdquo;].x = 4 报错\n对于类似 X = Y的赋值操作，必须知道 X 的地址，才能够将 Y 的值赋给 X， 但 go 中的 map 的 value 本身是不可寻址的\n正确写法 有两种解决方法：\n第一种：\n1 2 3 square := m[\u0026#34;foo\u0026#34;] square.x = 1 m[\u0026#34;foo\u0026#34;] = square 第二种：\n1 2 3 4 var m = map[string]*Math{ \u0026#34;foo\u0026#34;: \u0026amp;Math{2, 3}, } m[\u0026#34;foo\u0026#34;].x = 1 43. 下面代码输出什么？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 var p *int func foo() (*int, error) { var i int = 5 return \u0026amp;i, nil } func bar() { //use p fmt.Println(*p) } func Test43(t *testing.T) { p, err := foo() if err != nil { fmt.Println(err) return } bar() fmt.Println(*p) } 答案 bar 函数会发生panic，空指针异常\n因为 err 前面没有声明，所以 p, err := foo() 中的 p 是重新声明的局部变量，而不是我们在前面声明的全局变量 p\n44. 下面代码输出什么？ 1 2 3 4 5 6 7 func Test44(t *testing.T) { v := []int{1, 2, 3} for i := range v { v = append(v, i) fmt.Println(v) } } 答案 [1 2 3 0]\n[1 2 3 0 1]\n[1 2 3 0 1 2]\n45. 下面代码输出什么？ 1 2 3 4 5 6 7 8 9 10 11 func Test45(t *testing.T) { var m = [...]int{1, 2, 3} for i, v := range m { go func() { fmt.Println(i, v) }() } time.Sleep(time.Second * 1) } 答案 2 3\n2 3\n2 3\nfor range 使用短变量声明(:=)的形式迭代变量， 需要注意的是，变量 i、v 在每次循环体中都会被重用，而不是重新声明。\n解决方案 有两种解决方式\n第一种(推荐)\n1 2 3 4 5 for i, v := range m { go func(i,v int) { fmt.Println(i, v) }(i,v) } 第二种\n1 2 3 4 5 6 7 for i, v := range m { i := i // 这里的 := 会重新声明变量，而不是重用 v := v go func() { fmt.Println(i, v) }() } 46. 下面代码输出什么？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func f46(n int) (r int) { defer func() { r += n recover() }() var f func() defer f() f = func() { r += 2 } return n + 1 } func Test46(t *testing.T) { fmt.Println(f46(3)) } 答案 7\n47. 下列代码输出什么？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func Test47(t *testing.T) { var a = [5]int{1, 2, 3, 4, 5} var r [5]int for i, v := range a { if i == 0 { a[1] = 12 a[2] = 13 } r[i] = v } fmt.Println(\u0026#34;r = \u0026#34;, r) fmt.Println(\u0026#34;a = \u0026#34;, a) } 答案 r = [1 2 3 4 5]\na = [1 12 13 4 5]\n48. 下面代码输出什么？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func change(s ...int) { s = append(s, 3) } func Test48(t *testing.T) { slice := make([]int, 5, 5) slice[0] = 1 slice[1] = 2 // 1 change(slice...) fmt.Println(slice) // 2 change(slice[0:2]...) fmt.Println(slice) } 答案 [1 2 0 0 0]\n[1 2 3 0 0]\n1.change函数内部append时超出了s的容量，生成了新的底层数组的切片， 未对change函数外的切片产生影响。\n2.change函数收到的切片长度小于容量，append没有重新生成底层数组， 直接修改了底层数组对应位置的值，影响到了change函数外的切片。\n49. 下列代码输出什么？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func Test49(t *testing.T) { var m = map[string]int{ \u0026#34;A\u0026#34;: 21, \u0026#34;B\u0026#34;: 22, \u0026#34;C\u0026#34;: 23, } counter := 0 for k, v := range m { if counter == 0 { delete(m, \u0026#34;A\u0026#34;) } counter++ fmt.Println(k, v) } fmt.Println(\u0026#34;counter is \u0026#34;, counter) } 答案 counter is 2 或者 counter is 3\nfor range map 是无序的，若先遍历到A则counter是3，否则是2\n50. 关于协程，下列说法正确的有？ A. 协程和线程都可以实现程序的并发执行；\nB. 线程比协程更轻量级；\nC. 协程不存在死锁问题；\nD. 通过 channel 来进行协程间的通信；\n答案 A D\n51.关于循环语句，下面说法正确的有？ A. 循环语句既支持 for 关键字，也支持 while 和 do-while；\nB. 关键字 for 的基本使用方法与 C/C++ 中没有任何差异；\nC. for 循环支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环；\nD. for 循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量；\n答案 C D\n52. 下列代码输出什么？ 1 2 3 4 5 6 func Test52(t *testing.T) { i := 1 s := []string{\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;} i, s[i-1] = 2, \u0026#34;Z\u0026#34; fmt.Printf(\u0026#34;s: %v \\n\u0026#34;, s) } 答案 s: [Z B C]\n53. .关于switch语句，下面说法正确的有? A. 条件表达式必须为常量或者整数；\nB. 单个case中，可以出现多个结果选项；\nC. 需要用break来明确退出一个case；\nD. 只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case；\n答案 B D\n54. 下列Add函数定义正确的是？ 1 2 3 4 5 6 7 func Test54(t *testing.T) { var a Integer = 1 var b Integer = 2 var i interface{} = \u0026amp;a sum := i.(*Integer).Add(b) fmt.Println(sum) } A. type Integer int func (a Integer) Add(b Integer) Integer { return a + b } B. type Integer int func (a Integer) Add(b *Integer) Integer { return a + *b } C. type Integer int func (a *Integer) Add(b Integer) Integer { return *a + b } D. type Integer int func (a *Integer) Add(b *Integer) Integer { return *a + *b } 答案 A C\n55. 关于 bool 变量 b 的赋值，下面错误的用法是？ A. b = true\nB. b = 1\nC. b = bool(1)\nD. b = (1 == 2)\n答案 B C\n56. 关于变量的自增和自减操作，下面语句正确的是？ A.\n1 2 i := 1 i++ B.\n1 2 i := 1 j = i++ C.\n1 2 i := 1 ++i D.\n1 2 i := 1 i-- 答案 A D\ngo 里面没有 ++i 和 \u0026ndash;i\n56. 关于GetPodAction定义，下面赋值正确的是 1 2 3 4 5 6 7 8 9 type Fragment interface { Exec(transInfo *TransInfo) error } type GetPodAction struct { } func (g GetPodAction) Exec(transInfo *TransInfo) error { ... return nil } A. var fragment Fragment = new(GetPodAction)\nB. var fragment Fragment = GetPodAction\nC. var fragment Fragment = \u0026amp;GetPodAction{}\nD. var fragment Fragment = GetPodAction{}\n答案 A C D\n58. 关于整型切片的初始化，下面正确的是？ A. s := make([]int)\nB. s := make([]int, 0)\nC. s := make([]int, 5, 10)\nD. s := []int{1, 2, 3, 4, 5}\n答案 B C D\n59. 下列代码是否会触发异常？ 1 2 3 4 5 6 7 8 9 10 11 12 13 func Test59(t *testing.T) { runtime.GOMAXPROCS(1) intChan := make(chan int, 1) stringChan := make(chan string, 1) intChan \u0026lt;- 1 stringChan \u0026lt;- \u0026#34;hello\u0026#34; select { case value := \u0026lt;-intChan: fmt.Println(value) case value := \u0026lt;-stringChan: panic(value) } } 答案 不一定，当两个chan同时有值时，select 会随机选择一个可用通道做收发操作\n60. 关于channel的特性，下面说法正确的是？ A. 给一个 nil channel 发送数据，造成永远阻塞\nB. 从一个 nil channel 接收数据，造成永远阻塞\nC. 给一个已经关闭的 channel 发送数据，引起 panic\nD. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值\n答案 A B C D\n61. 下列代码有什么问题？ 1 2 3 4 5 6 7 const i = 100 var j = 123 func main() { fmt.Println(\u0026amp;j, j) fmt.Println(\u0026amp;i, i) } 答案 Go语言中，常量无法寻址, 是不能进行取指针操作的\n62. 下列代码输出什么？ 1 2 3 4 5 6 func Test62(t *testing.T) { x := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} for v := range x { fmt.Print(v) } } 答案 012\nrange 一个返回值时，这个值是下标，两个值时，第一个是下标，第二个是值，当 x 为 map时，第一个是key，第二个是value\n63. 关于无缓冲和有冲突的channel，下面说法正确的是？ A. 无缓冲的channel是默认的缓冲为1的channel；\nB. 无缓冲的channel和有缓冲的channel都是同步的；\nC. 无缓冲的channel和有缓冲的channel都是非同步的；\nD. 无缓冲的channel是同步的，而有缓冲的channel是非同步的；\n答案 D\n64. 下列代码输出什么？ 1 2 3 4 5 6 7 8 9 10 11 func Foo(x interface{}) { if x == nil { fmt.Println(\u0026#34;empty interface\u0026#34;) return } fmt.Println(\u0026#34;non-empty interface\u0026#34;) } func Test64(t *testing.T) { var x *int = nil Foo(x) } 答案 non-empty interface\n接口除了有静态类型，还有动态类型和动态值， 当且仅当动态值和动态类型都为 nil 时，接口类型值才为 nil。 这里的 x 的动态类型是 *int，所以 x 不为 nil\n65. 关于select机制，下面说法正确的是? A. select机制用来处理异步IO问题；\nB. select机制最大的一条限制就是每个case语句里必须是一个IO操作；\nC. golang在语言级别支持select关键字；\nD. select关键字的用法与switch语句非常类似，后面要带判断条件；\n答案 A B C\n66. 下列代码有什么问题？ 1 2 3 func Stop(stop \u0026lt;-chan bool) { close(stop) } 答案 只可以接收数据的 channel 不可以被关闭\n67. 下列代码输出什么？ 1 2 3 4 func Test67(t *testing.T) { var x = []int{2: 2, 3, 0: 1} fmt.Println(x) } 答案 [1 0 2 3]\n68. 下列代码输出什么？ 1 2 3 4 5 6 7 8 9 func incr(p *int) int { *p++ return *p } func Test68(t *testing.T) { v := 1 incr(\u0026amp;v) fmt.Println(v) } 答案 2\n69. 下列代码输出什么？ 1 2 3 4 5 6 7 8 9 10 11 12 func Test69(t *testing.T) { var a = []int{1, 2, 3, 4, 5} var r = make([]int, 0) for i, v := range a { if i == 0 { a = append(a, 6, 7) } r = append(r, v) } fmt.Println(r) } 答案 [1 2 3 4 5]\na 在 for range 过程中增加了两个元素 len 由 5 增加到 7，但 for range 时会使用 a 的副本 a\u0026rsquo; 参与循环，副本的 len 依旧是 5， 因此 for range 只会循环 5 次，也就只获取 a 对应的底层数组的前 5 个元素。\n70. 下列代码有什么问题？ 1 2 3 4 5 6 7 func main() { var s []int s = append(s,1) var m map[string]int m[\u0026#34;one\u0026#34;] = 1 } 答案 切片可以开箱即用，但 map 需要用 make函数 进行初始化之后才能赋值\n71. 下列函数能否正确输出? 1 2 3 4 5 6 7 8 func main() { var fn1 = func() {} var fn2 = func() {} if fn1 != fn2 { println(\u0026#34;fn1 not equal fn2\u0026#34;) } } 答案 编译错误，func 只能与 nil 做比较\n72. 下列代码是否正确? 1 2 3 4 5 6 7 8 9 type T struct { n int } func main() { m := make(map[int]T) m[0].n = 1 fmt.Println(m[0].n) } 答案 编译错误, map[key]struct 中 struct 是不可寻址的，所以无法直接赋值。\n修复 1 2 3 4 5 6 func main() { m := make(map[int]T) t := T{1} m[0] = t fmt.Println(m[0].n) } 73. 下列代码有什么问题? 1 2 3 4 5 6 7 8 9 10 type X struct {} func (x *X) test() { println(x) } func main() { var a *X a.test() X{}.test() } 答案 X{} 是不可寻址的，不能直接调用方法\n修复 1 2 3 4 5 6 7 func main() { var a *X a.test() // 为其定义一个变量，让其可寻址 var x = X{} x.test() } 74. 关于 channel 下面描述正确的是？ A. 向已关闭的通道发送数据会引发 panic；\nB. 从已关闭的缓冲通道接收数据，返回已缓冲数据或者零值；\nC. 无论接收还是接收，nil 通道都会阻塞；\nD. close() 可以用于只接收通道；\nE. 单向通道可以转换为双向通道；\nF. 不能在单向通道上做逆向操作（例如：只发送通道用于接收）；\n答案 A B C F\n75. 下列代码输出什么? 1 2 3 4 5 6 func Test75(t *testing.T) { s := make([]int, 3, 9) fmt.Println(len(s)) s2 := s[4:8] fmt.Println(len(s2)) } 答案 3 4\n76. 下列哪一行会panic? 1 2 3 4 5 6 7 func Test76(t *testing.T) { var x interface{} var y interface{} = []int{3, 5} _ = x == x _ = x == y _ = y == y } 答案 _ = y == y 会发生panic, 因为两个比较值的动态类型为同一个不可比较类型\n77. 下列哪行代码会panic? 1 2 3 4 5 6 func Test77(t *testing.T) { x := make([]int, 2, 10) _ = x[6:10] _ = x[6:] _ = x[2:] } 答案 _ = x[6:] 这一行会发生panic, 截取符号 [i:j]， 如果 j 省略，默认是原切片或者数组的长度，x 的长度是 2，小于起始下标 6 ，所以 panic\n78. 下列代码有什么问题? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 type data struct { sync.Mutex } func (d data) test(s string) { d.Lock() defer d.Unlock() for i := 0; i \u0026lt; 5; i++ { fmt.Println(s, i) time.Sleep(time.Second) } } func Test78(t *testing.T) { var wg sync.WaitGroup wg.Add(2) var d data go func() { defer wg.Done() d.test(\u0026#34;read\u0026#34;) }() go func() { defer wg.Done() d.test(\u0026#34;write\u0026#34;) }() wg.Wait() } 答案 锁失效。将 Mutex 作为匿名字段时，相关的方法必须使用指针接收者，否则会导致锁机制失效。\n修复 1 2 3 4 5 6 7 8 9 10 // 指针接收者 func (d *data) test(s string) { d.Lock() defer d.Unlock() for i:=0;i\u0026lt;5 ;i++ { fmt.Println(s,i) time.Sleep(time.Second) } } 79. 下列代码输出什么? 1 2 3 4 5 6 func Test79(t *testing.T) { var k = 1 var s = []int{1, 2} k, s[k] = 0, 3 fmt.Println(s[0] + s[1]) } 答案 4\n80. 下列那行代码会panic? 1 2 3 4 5 func Test80(t *testing.T) { nil := 123 fmt.Println(nil) var _ map[string]int = nil } 答案 var _ map[string]int = nil 会编译错误， 当前作用域中， 预定义的 nil 被覆盖，此时 nil 是 int 类型值，不能赋值给 map 类型。\n81. 下列代码输出什么? 1 2 3 4 5 func Test81(t *testing.T) { var x int8 = -128 var y = x / -1 fmt.Println(y) } 答案 -128, 因为溢出 int8为 -128 ~ 127 之间\n82. 下列代码输出什么? 1 2 3 4 5 6 7 8 9 10 11 func Test82(t *testing.T) { defer func() { fmt.Println(recover()) }() defer func() { defer fmt.Println(recover()) panic(1) }() defer recover() panic(2) } 答案 2 1, recover() 必须在 defer函数体内使用才有效，所以 defer recover() 是无效的\n83. 关于字符串拼接,下列正确的是? A. str := \u0026lsquo;abc\u0026rsquo; + \u0026lsquo;123\u0026rsquo;\nB. str := \u0026ldquo;abc\u0026rdquo; + \u0026ldquo;123\u0026rdquo;\nC. str ：= \u0026lsquo;123\u0026rsquo; + \u0026ldquo;abc\u0026rdquo;\nD. fmt.Sprintf(\u0026ldquo;abc%d\u0026rdquo;, 123)\n答案 B D 双引号用来表示字符串 string，其实质是一个 byte 类型的数组，单引号表示 rune 类型。\n84. 下列代码有什么问题? 1 2 3 4 5 6 7 8 9 10 func main() { runtime.GOMAXPROCS(1) go func() { for i:=0;i\u0026lt;10 ;i++ { fmt.Println(i) } }() for {} } 答案 for{} 独占 CPU 资源导致其他 Goroutine 饿死\n修复 1 2 3 4 5 6 7 8 9 10 func main() { runtime.GOMAXPROCS(1) go func() { for i:=0;i\u0026lt;10 ;i++ { fmt.Println(i) } }() select {} } 85. 下列代码有什么问题? 1 2 3 4 5 6 7 8 9 10 func main() { f, err := os.Open(\u0026#34;file\u0026#34;) defer f.Close() if err != nil { return } b, err := ioutil.ReadAll(f) println(string(b)) } 答案 应该先判断 err, 再用defer 关闭文件句柄\n86. 下列代码有什么问题? 1 2 3 4 5 6 7 8 9 10 func main() { var wg sync.WaitGroup wg.Add(1) go func() { fmt.Println(\u0026#34;1\u0026#34;) wg.Done() wg.Add(1) }() wg.Wait() } 答案 协程里面，使用 wg.Add(1) 但是没有 wg.Done()，导致 panic()。\n87. 下列代码输出什么? 1 2 3 4 5 6 7 8 9 func printI(num ...int) { num[0] = 18 } func Test87(t *testing.T) { i := []int{5, 6, 7} printI(i...) fmt.Println(i[0]) } 答案 18, 可变参数是指针传递\n88. 下列代码输出什么? 1 2 3 4 5 6 7 8 9 10 11 12 func alwaysFalse() bool { return false } func Test88(t *testing.T) { switch alwaysFalse(); { case true: println(true) case false: println(false) } } 答案 true, Go代码断行规则\n89. 下列代码有什么问题? 1 2 3 4 5 6 7 8 9 10 11 12 type ConfigOne struct { Daemon string } func (c *ConfigOne) String() string { return fmt.Sprintf(\u0026#34;print: %v\u0026#34;, c) } func main() { c := \u0026amp;ConfigOne{} c.String() } 答案 无限循环，栈溢出, 如果结构体类型定义了 String() 方法， 使用 Printf()、Print() 、 Println() 、 Sprintf() 等格式化输出时会自动使用 String() 方法。\n90. 下列代码有什么问题? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { wg := sync.WaitGroup{} for i := 0; i \u0026lt; 5; i++ { go func(wg sync.WaitGroup, i int) { wg.Add(1) fmt.Printf(\u0026#34;i:%d\\n\u0026#34;, i) wg.Done() }(wg, i) } wg.Wait() fmt.Println(\u0026#34;exit\u0026#34;) } 答案 在协程中使用了 wg.Add(1)\n使用了 sync.WaitGroup 副本\n修复 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { wg := sync.WaitGroup{} for i := 0; i \u0026lt; 5; i++ { wg.Add(1) go func(i int) { fmt.Printf(\u0026#34;i:%d\\n\u0026#34;, i) wg.Done() }(i) } wg.Wait() fmt.Println(\u0026#34;exit\u0026#34;) } 91. 下列代码输出什么? 1 2 3 4 5 6 7 8 9 10 11 12 func main() { a := [3]int{0, 1, 2} s := a[1:2] s[0] = 11 s = append(s, 12) s = append(s, 13) s[0] = 21 fmt.Println(a) fmt.Println(s) } 答案 [0 11 12]\n[21 12 13]\n92. 下列代码输出什么? 1 2 3 func Test92(t *testing.T) { fmt.Println(strings.TrimRight(\u0026#34;ABBA\u0026#34;, \u0026#34;BA\u0026#34;)) } 答案 输出空字符串, TrimRight() 会将第二个参数字符串里面所有的字符拿出来处理， 只要与其中任何一个字符相等，便会将其删除。想正确地截取字符串，可以参考 TrimSuffix() 函数。\n93. 下列代码输出什么? 1 2 3 4 5 6 func Test93(t *testing.T) { var src, dst []int src = []int{1, 2, 3} copy(dst, src) fmt.Println(dst) } 答案 输出 [], 如果想要将 src 完全拷贝至 dst，必须给 dst 分配足够的内存空间。\n修复 1 2 3 4 5 6 7 func Test93(t *testing.T) { var src, dst []int src = []int{1, 2, 3} dst = make([]int, len(src)) copy(dst, src) fmt.Println(dst) } 或者直接使用append\n1 2 3 4 5 6 func Test93(t *testing.T) { var src, dst []int src = []int{1, 2, 3} dst = append(dst, src...) fmt.Println(dst) } 94. 下列代码是否可以编译通过? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type User struct { Name string } func (u *User) SetName(name string) { u.Name = name fmt.Println(u.Name) } type Employee User func main() { employee := new(Employee) employee.SetName(\u0026#34;Jack\u0026#34;) } 答案 编译不通过, 当使用 type 声明一个新类型，它不会继承原有类型的方法集。\n95. 关于map，下面说法正确的是？ A. map 反序列化时 json.unmarshal() 的入参必须为 map 的地址；\nB. 在函数调用中传递 map，则子函数中对 map 元素的增加不会导致父函数中 map 的修改；\nC. 在函数调用中传递 map，则子函数中对 map 元素的修改不会导致父函数中 map 的修改；\nD. 不能使用内置函数 delete() 删除 map 的元素\n答案 A\n96. 关于同步锁，下面说法正确的是？ A. 当一个 goroutine 获得了 Mutex 后，其他 goroutine 就只能乖乖的等待，除非该 goroutine 释放这个 Mutex；\nB. RWMutex 在读锁占用的情况下，会阻止写，但不阻止读；\nC. RWMutex 在写锁占用情况下，会阻止任何其他 goroutine（无论读和写）进来，整个锁相当于由该 goroutine 独占；\nD. Lock() 操作需要保证有 Unlock() 或 RUnlock() 调用与之对应；\n答案 A B C , 106\nWritten with StackEdit.\n","pubDate":"2022-10-08","title":"Go面试题及详解"},{"link":"https://caojunsheng.github.io/posts/fix-stackedit-400/","plain":"stackedit在弹出网页转到github授权界面的时候，弹出来了http400的错误，在你点授权之前，F12打开console，输入下边的JS code：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 window.XMLHttpRequest = class MyXMLHttpRequest extends window.XMLHttpRequest { open(...args){ if(args[1].startsWith(\u0026#34;https://api.github.com/user?access_token=\u0026#34;)) { // apply fix as described by github // https://developer.github.com/changes/2020-02-10-deprecating-auth-through-query-param/#changes-to-make const segments = args[1].split(\u0026#34;?\u0026#34;); args[1] = segments[0]; // remove query params from url const token = segments[1].split(\u0026#34;=\u0026#34;)[1]; // save the token const ret = super.open(...args); this.setRequestHeader(\u0026#34;Authorization\u0026#34;, `token ${token}`); // set required header return ret; } else { return super.open(...args); } } } 这段代码会重写stackedit的API请求，可以成功解决400的问题，成功授权。\nWritten with StackEdit.\n","pubDate":"2022-09-29","title":"stackedit跳转github授权报错400解决"},{"link":"https://caojunsheng.github.io/posts/first-post/","plain":" This is My First Blog\n我告诉你，出来混，有错就要认，挨打要立正。 test ","pubDate":"2022-09-17","title":"First Post"},{"link":"https://caojunsheng.github.io/posts/golang/05_chan_close/","plain":"4、chan关闭流程 参考https://www.bookstack.cn/read/qcrao-Go-Questions/channel.md\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 func closechan(c *hchan) { if c == nil { // 关闭nil的chan直接panic panic(plainError(\u0026#34;close of nil channel\u0026#34;)) } lock(\u0026amp;c.lock) if c.closed != 0 { unlock(\u0026amp;c.lock) // 关闭已关闭的chan直接panic panic(plainError(\u0026#34;close of closed channel\u0026#34;)) } if raceenabled { callerpc := getcallerpc() racewritepc(c.raceaddr(), callerpc, funcPC(closechan)) racerelease(c.raceaddr()) } // 标志位打上 c.closed = 1 var glist gList // release all readers for { sg := c.recvq.dequeue() if sg == nil { break } // 赋值零值 if sg.elem != nil { typedmemclr(c.elemtype, sg.elem) sg.elem = nil } if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } // release all writers (they will panic) for { sg := c.sendq.dequeue() if sg == nil { break } // 发送者会panic sg.elem = nil if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } unlock(\u0026amp;c.lock) // Ready all Gs now that we\u0026#39;ve dropped the channel lock. for !glist.empty() { gp := glist.pop() gp.schedlink = 0 goready(gp, 3) } } ","pubDate":"2021-09-17","title":"golang chan close源码分析"},{"link":"https://caojunsheng.github.io/posts/golang/03_chan_recv/","plain":"2、chan读取源码分析 chan的读取源码入口是如下两个函数：\n1 2 3 4 5 6 7 8 9 // 读取的数据放在elem里面，两种读取的方式，第一种直接返回值，第二种返回一个bool值，判断chan是否关闭 func chanrecv1(c *hchan, elem unsafe.Pointer) { chanrecv(c, elem, true) } func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) { _, received = chanrecv(c, elem, true) return } chanrecv1不返回ok，chanrecv2返回ok，两个最终都是调用chanrecv函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 // src/runtime/chan.go:454 // chanrecv 函数接收 channel c 的元素并将其写入 ep 所指向的内存地址。 // 如果 ep 是 nil，说明忽略了接收值。 // 如果 block == false，即非阻塞型接收，在没有数据可接收的情况下，返回 (false, false) // 否则，如果 c 处于关闭状态，将 ep 指向的地址清零，返回 (true, false) // 否则，用返回值填充 ep 指向的内存地址。返回 (true, true) // 如果 ep 非空，则应该指向堆或者函数调用者的栈 func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { ... // 如果chan是nil的话 if c == nil { // 非阻塞调用，则直接返回false, false if !block { return } // 阻塞调用，一直等待接收nil的chan，goroutine挂起 gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2) throw(\u0026#34;unreachable\u0026#34;) } // 如果是非阻塞且chan是空的 if !block \u0026amp;\u0026amp; empty(c) { // 如果chan是未关闭的，直接返回false,false if atomic.Load(\u0026amp;c.closed) == 0 { return } // chan已经关闭，并且为空，老实说。这段代码感觉有点多余，下面也处理了这种情况 if empty(c) { // The channel is irreversibly closed and empty. if raceenabled { raceacquire(c.raceaddr()) } if ep != nil { // 对于已关闭的chan执行接收，不忽略返回值的情况下，会受到该类型的零值，清理ep的内存 typedmemclr(c.elemtype, ep) } // 返回selected为true return true, false } } var t0 int64 if blockprofilerate \u0026gt; 0 { t0 = cputicks() } lock(\u0026amp;c.lock) // chan已经关闭，且缓存中无数据，直接返回该类型的零值 if c.closed != 0 \u0026amp;\u0026amp; c.qcount == 0 { if raceenabled { raceacquire(c.raceaddr()) } unlock(\u0026amp;c.lock) if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } if sg := c.sendq.dequeue(); sg != nil { // 如果sender中有等待发送，那么可以分为两种情况 // 1、非缓冲队列，即同步chan，则直接从sender中接收值。 // 2、缓冲队列，即异步chan，从缓冲队列的头部拷贝到接收者，拷贝发送队列的值到缓冲队列末尾 recv(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true, true } // 缓冲型chan，buf里面有元素，直接从buf里面拿 if c.qcount \u0026gt; 0 { // Receive directly from queue qp := chanbuf(c, c.recvx) if raceenabled { racenotify(c, c.recvx, nil) } // 代码里面需要接收值，则需要拷贝值，比如接收是`val\u0026lt;-ch`，而不是`\u0026lt;-ch`，需要把chan的值拷贝到val if ep != nil { typedmemmove(c.elemtype, ep, qp) } // 清空掉原来buf中对应位置的值 typedmemclr(c.elemtype, qp) // 接收index+1 c.recvx++ // 如果接收索引已经到末尾，重新移到队首 if c.recvx == c.dataqsiz { c.recvx = 0 } // 缓冲区大小减一 c.qcount-- // 解锁 unlock(\u0026amp;c.lock) return true, true } if !block { // 非阻塞接收，解锁，返回false,false unlock(\u0026amp;c.lock) return false, false } // 无发送者，这个接收值需要被阻塞. gp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // 构造一个接收数据的sudog. mysg.elem = ep mysg.waitlink = nil gp.waiting = mysg mysg.g = gp mysg.isSelect = false mysg.c = c gp.param = nil // 放入接受者队列中 c.recvq.enqueue(mysg) // 将goroutine挂起 atomic.Store8(\u0026amp;gp.parkingOnChan, 1) gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, 2) // someone woke us up if mysg != gp.waiting { throw(\u0026#34;G waiting list is corrupted\u0026#34;) } gp.waiting = nil gp.activeStackChans = false if mysg.releasetime \u0026gt; 0 { blockevent(mysg.releasetime-t0, 2) } success := mysg.success gp.param = nil mysg.c = nil releaseSudog(mysg) return true, success } empty源码分析\n如果是非缓冲型，且sendq中无goroutine\n缓冲型，但是buf里面没有元素\n1 2 3 4 5 6 7 func empty(c *hchan) bool { // c.dataqsiz is immutable. if c.dataqsiz == 0 { return atomic.Loadp(unsafe.Pointer(\u0026amp;c.sendq.first)) == nil } return atomic.Loaduint(\u0026amp;c.qcount) == 0 } ","pubDate":"2021-09-17","title":"golang chan recv源码分析"},{"link":"https://caojunsheng.github.io/posts/golang/04_chan_send/","plain":"3、chan写入源码分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { // 如果chan是空 if c == nil { // 非阻塞，直接返回false，表示未发送成功 if !block { return false } // 阻塞的，挂起goroutine gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2) throw(\u0026#34;unreachable\u0026#34;) } ... // 如果是非阻塞的，chan未关闭，且chan的buffer已经满了，则返回发送失败 if !block \u0026amp;\u0026amp; c.closed == 0 \u0026amp;\u0026amp; full(c) { return false } var t0 int64 if blockprofilerate \u0026gt; 0 { t0 = cputicks() } lock(\u0026amp;c.lock) if c.closed != 0 { unlock(\u0026amp;c.lock) // 如果chan已经关闭了，再向chan发送数据，直接报panic panic(plainError(\u0026#34;send on closed channel\u0026#34;)) } if sg := c.recvq.dequeue(); sg != nil { // 如果有接受者在等待，直接将发送的数据拷贝到 send(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true } // 如果缓冲的chan，还有空间，将发送的数据拷贝到buffer中 if c.qcount \u0026lt; c.dataqsiz { qp := chanbuf(c, c.sendx) if raceenabled { racenotify(c, c.sendx, nil) } typedmemmove(c.elemtype, qp, ep) // 发送游标+1 c.sendx++ // 发送游标已经到末尾了，重新移到队头 if c.sendx == c.dataqsiz { c.sendx = 0 } // 缓冲区数量+1 c.qcount++ unlock(\u0026amp;c.lock) return true } // 非阻塞的chan，直接返回写入失败 if !block { unlock(\u0026amp;c.lock) return false } // chan满了，发送者会被阻塞，构造一个sudog挂起 gp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } mysg.elem = ep mysg.waitlink = nil mysg.g = gp mysg.isSelect = false mysg.c = c gp.waiting = mysg gp.param = nil // 构造sudog放入发送者队列 c.sendq.enqueue(mysg) atomic.Store8(\u0026amp;gp.parkingOnChan, 1) gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, 2) KeepAlive(ep) // someone woke us up. if mysg != gp.waiting { throw(\u0026#34;G waiting list is corrupted\u0026#34;) } gp.waiting = nil gp.activeStackChans = false closed := !mysg.success gp.param = nil if mysg.releasetime \u0026gt; 0 { blockevent(mysg.releasetime-t0, 2) } mysg.c = nil releaseSudog(mysg) if closed { if c.closed == 0 { throw(\u0026#34;chansend: spurious wakeup\u0026#34;) } panic(plainError(\u0026#34;send on closed channel\u0026#34;)) } return true } send源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // send 函数处理向一个空的 channel 发送操作 // ep 指向被发送的元素，会被直接拷贝到接收的 goroutine // 之后，接收的 goroutine 会被唤醒 // c 必须是空的（因为等待队列里有 goroutine，肯定是空的） // c 必须被上锁，发送操作执行完后，会使用 unlockf 函数解锁 // sg 必须已经从等待队列里取出来了 // ep 必须是非空，并且它指向堆或调用者的栈 func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { // 省略一些用不到的 // …… // sg.elem 指向接收到的值存放的位置，如 val \u0026lt;- ch，指的就是 \u0026amp;val if sg.elem != nil { // 直接拷贝内存（从发送者到接收者） sendDirect(c.elemtype, sg, ep) sg.elem = nil } // sudog 上绑定的 goroutine gp := sg.g // 解锁 unlockf() gp.param = unsafe.Pointer(sg) if sg.releasetime != 0 { sg.releasetime = cputicks() } // 唤醒接收的 goroutine. skip 和打印栈相关，暂时不理会 goready(gp, skip+1) } full源码\n1 2 3 4 5 6 7 8 func full(c *hchan) bool { // 非缓冲chan，判断recvq为空，则认为满 if c.dataqsiz == 0 { return c.recvq.first == nil } // 缓冲chan，缓冲区数量等于chan大小 return c.qcount == c.dataqsiz } ","pubDate":"2021-09-17","title":"golang chan send源码分析"},{"link":"https://caojunsheng.github.io/posts/golang/02_chan_data_structure/","plain":"二、chan源码解读 1、chan数据结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 type hchan struct { // chan 里元素数量 qcount uint // chan 底层循环数组的长度 dataqsiz uint // 指向底层循环数组的指针 // 只针对有缓冲的 channel buf unsafe.Pointer // chan 中元素大小 elemsize uint16 // chan 是否被关闭的标志 closed uint32 // chan 中元素类型 elemtype *_type // element type // 已发送元素在循环数组中的索引 sendx uint // send index // 已接收元素在循环数组中的索引 recvx uint // receive index // 等待接收的 goroutine 队列 recvq waitq // list of recv waiters // 等待发送的 goroutine 队列 sendq waitq // list of send waiters // 保护 hchan 中所有字段 lock mutex } type waitq struct { first *sudog last *sudog } buf 指向底层循环数组，只有缓冲型的 channel 才有。\nsendx，recvx 均指向底层循环数组，表示当前可以发送和接收的元素位置索引值（相对于底层数组）。\nsendq，recvq 分别表示被阻塞的 goroutine，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据而被阻塞。\nwaitq 是 sudog 的一个双向链表，而 sudog 实际上是对 goroutine 的一个封装。\n例如，创建一个容量为 6 的，元素为 int 型的 channel 数据结构如下 ： ","pubDate":"2021-09-17","title":"golang chan数据结构"},{"link":"https://caojunsheng.github.io/posts/golang/01_chan/","plain":"一、golang里面几个chan常见的坑 1、向chan发送数据 向已关闭的chan发送数据会panic\n1 2 3 4 5 // src/runtime/chan.go:202 if c.closed != 0 { unlock(\u0026amp;c.lock) panic(plainError(\u0026#34;send on closed channel\u0026#34;)) } 2、关闭chan 关闭nil的chan，会panic 对已关闭的chan，再次关闭chan，会panic 1 2 3 4 5 6 7 8 9 10 11 12 13 // src/runtime/chan.go:355 func closechan(c *hchan) { if c == nil { panic(plainError(\u0026#34;close of nil channel\u0026#34;)) } lock(\u0026amp;c.lock) if c.closed != 0 { unlock(\u0026amp;c.lock) panic(plainError(\u0026#34;close of closed channel\u0026#34;)) } ... } 3、读chan数据 chan关闭之后，关闭前放入的数据，仍然可以读取 已关闭的chan仍然可以读取，值为零值，返回值ok为false 如何优雅的关闭channel？\n根据 sender 和 receiver 的个数，分下面几种情况：\n一个 sender，一个 receiver 一个 sender， M 个 receiver N 个 sender，一个 reciver N 个 sender， M 个 receiver 1,2两种情况，仅一个sender，直接从sender端关闭channel即可\n第3种情况解决方案就是增加一个传递关闭信号的 channel，receiver 通过信号 channel 下达关闭数据 channel 指令。senders 监听到关闭信号后，停止发送数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func main() { rand.Seed(time.Now().UnixNano()) const Max = 100000 const NumSenders = 1000 dataCh := make(chan int, 100) stopCh := make(chan struct{}) // senders for i := 0; i \u0026lt; NumSenders; i++ { go func() { for { select { case \u0026lt;- stopCh: return case dataCh \u0026lt;- rand.Intn(Max): } } }() } // the receiver go func() { for value := range dataCh { if value == Max-1 { fmt.Println(\u0026#34;send stop signal to senders.\u0026#34;) close(stopCh) return } fmt.Println(value) } }() select { case \u0026lt;- time.After(time.Hour): } } 对于第4种情况，和第 3 种情况不同，这里有 M 个 receiver，如果直接还是采取第 3 种解决方案，由 receiver 直接关闭 stopCh 的话，就会重复关闭一个 channel，导致 panic。因此需要增加一个中间人，M 个 receiver 都向它发送关闭 dataCh 的“请求”，中间人收到第一个请求后，就会直接下达关闭 dataCh 的指令（通过关闭 stopCh，这时就不会发生重复关闭的情况，因为 stopCh 的发送方只有中间人一个）。另外，这里的 N 个 sender 也可以向中间人发送关闭 dataCh 的请求。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 func main() { rand.Seed(time.Now().UnixNano()) const Max = 100000 const NumReceivers = 10 const NumSenders = 1000 dataCh := make(chan int, 100) stopCh := make(chan struct{}) // It must be a buffered channel. toStop := make(chan string, 1) var stoppedBy string // moderator go func() { stoppedBy = \u0026lt;-toStop close(stopCh) }() // senders for i := 0; i \u0026lt; NumSenders; i++ { go func(id string) { for { value := rand.Intn(Max) if value == 0 { select { case toStop \u0026lt;- \u0026#34;sender#\u0026#34; + id: default: } return } select { case \u0026lt;- stopCh: return case dataCh \u0026lt;- value: } } }(strconv.Itoa(i)) } // receivers for i := 0; i \u0026lt; NumReceivers; i++ { go func(id string) { for { select { case \u0026lt;- stopCh: return case value := \u0026lt;-dataCh: if value == Max-1 { select { case toStop \u0026lt;- \u0026#34;receiver#\u0026#34; + id: default: } return } fmt.Println(value) } } }(strconv.Itoa(i)) } select { case \u0026lt;- time.After(time.Hour): } } ","pubDate":"2021-09-17","title":"golang里面几个chan常见的坑"}];
    

</script>





    </body>
</html>

